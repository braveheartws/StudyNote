## 程序员的自我修养

### 第一章 计算机基础知识

**总线(Bus)**:总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由[导线](https://baike.baidu.com/item/导线/1413914)组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为[数据总线](https://baike.baidu.com/item/数据总线/272650)、[地址总线](https://baike.baidu.com/item/地址总线/4307936)和[控制总线](https://baike.baidu.com/item/控制总线/272568)，分别用来传输数据、数据地址和[控制信号](https://baike.baidu.com/item/控制信号/10329713)。

**南桥**:南桥设计用来处理低速信号，通过[北桥](https://baike.baidu.com/item/北桥)与[中央处理器](https://baike.baidu.com/item/中央处理器)联系。

**北桥**:北桥设计用来处理高速信号，通常处理[中央处理器](https://baike.baidu.com/item/中央处理器)、[存储器](https://baike.baidu.com/item/存储器)、[PCI Express](https://baike.baidu.com/item/PCI Express)显卡（早年是[AGP](https://baike.baidu.com/item/AGP)显卡）、高速PCI Express X16/X8的[端口](https://baike.baidu.com/item/端口)，还有与[南桥](https://baike.baidu.com/item/南桥)之间的通信。

> **计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决**

**接口**:每个层次之间都必须要互相通信,通信协议一般称之为接口. 除了硬件和应用程序,其他都是所谓的中间层,**每个中间层都是对他下面那层得包装与拓展**

**应用程序编程接口**

**软件中断**

**多道程序(Multiprogramming)**:早期的监控程序,当某个程序无需使用CPU时,监控程序会把另个正在等待CPU资源的程序启动.缺点是:程序之间不分轻重缓急,比如急需CPU处理一些任务(用户交互),可能需要等很长时间.

**分时系统(Time-Sharing System)**:改为协作模式,每个程序允许一段时间以后都主动让出CPU给其他程序,使得一段时间内每个程序都有机会运行一小段.缺点是:当某一个程序在进行一个耗时计算,一直霸占CPU,那么操作系统也没有办法,其他程序只能等 例如while(true)

**多任务(Multi-Tasking)系统**:操作系统接管硬件资源,程序已进程的方式运行在比操作系统权限更低的级别,CPU由操作系统统一分配,每个进程都有机会得到CPU,如果运行超出一定时间,操作系统会暂停该进程.分配给其他等待的程序,这方方式被称为抢占式

----

**硬盘结构**:硬盘基本存储单位为扇区(Sector),每个扇区一般为512字节,一个硬盘往往会有多个盘片,每个盘片有两面,每面按照同心圆划分为若干个磁道,每个磁道划分若干个扇区. 比如一个硬盘有2个盘面,每个盘面分65536个磁道,每个磁道分为1024个扇区,那么硬盘的容量等于: 2x2x65536x1024x512=128GB. 如果是同心圆那么肯定外围的磁道密度会比内圈更加稀疏,如果不同磁道扇区数不同,计算就会很麻烦,为了屏蔽这些复杂的硬件细节,现代硬盘普遍使用LBA(Logical Block Address): 对硬盘中的所有扇区从0开始编号,一直到最后一个扇区,当给出一个逻辑扇区号时,硬盘的电子设备会将其换成实际的盘面,磁道等位置

**一些名词**

- 虚拟地址(Virtual Address)
- 虚拟地址空间(Virtual Address Space)
- 物理地址空间(Physical Address Space)
- 分段(Segmentation)
- 分页(Paging)
- 虚拟页(VP, Virtual Page)
- 物理页(PP,Physical Page)
- 磁盘页(DP,Disk Page)

关于页的交换方式:

假如一个进程的虚拟页VP1,VP2不在内存中,但是进程需要用的这两个页的时候,硬件会捕捉到这个消息,这就是**页错误(Page Fault)**, 然后操作系统接管进程,负责将VP1和VP2从磁盘读出来并装入内存, 然后将内存中的这两个页与VP1与VP2建立映射关系. 

将不同进程的虚拟页映射到同一个物理页,这样就可以实现**内存共享**

#### 1.6 

##### 1.6.1 线程基础

**什么是线程**

> 线程有时被称为轻量级进程(Lightweight Process LWP),是程序执行流的最小单元. 一个标准的线程由线程ID, 当前指令针,寄存器集合和堆栈组成,通常意义上,一个进程由一个到多个线程组成,各个线程之间共享进程的内存空间(代码段 ,数据段  堆等)及一些进程级资源(文件,和信号)

![](./7.png)

![](./8.png)

**线程调度(Thread Schedule)**

* 运行: 正在执行
* 就绪: 可以立刻运行,但CPU已经被占用
* 等待:等待某一件事(I/O)

主流**线程调度算法**

* **优先级调度(Priority Schedule)**:windows和linux都有提供方法设置线程的优先级,高优先级的线程会更早的执行,低优先级常常需要系统中没有高优先级的可执行线程存在时才能够执行
* **轮转法(Round Robin)**: 让各个线程轮流执行一小段时间

**线程分类:**

* 把频繁等待的线程称为**IO密集型线程(IO Bound Thread)**
* 把很少等待的线程称为**CPU密集型线程(CPU Bound Thread)**

**改变线程优先级的三种方式**

* 用户指定优先级
* 根据等待状态的频繁程度提升或降低优先级
* 长时间得不到执行而被提升优先级

**Linux的多线程**

> windows内核有明确的线程和进程概念. 可以通过`CreateProces`和`CreateThread`来创建.
>
> 但是Linux将所有的执行实体(进程或者线程)都称为任务(Task), 每一个任务概念上都类似于一个单线程的进程,具有内存控件,执行实体,文件资源等. Linux下不同的任务之间可以选择共享内存空间, 共享了同一个内存控件的多任务构成了一个进程,这些任务也就是进程里的线程

![](./9.png)

**关于fork**

![](./10.png)

![](./11.png)

使用clone可以产生新的任务,从指定的位置开始执行,并且(可选)共享当前线程的内存空间和文件.

##### 1.6.2 线程安全

把单指令称为**原子的(tomic)**

**同步与锁**

> 在一个线程访问数据为结束的时候,其他线程不得对同一个数据进行访问

常见同步方法

* 锁(Lock): 包含 获取(Acquire), 释放(Release)
* 二元信号量(Binary Semaphore): 只有占用与非占用两种状态
* 多元信号量简称**信号量(Semaphore)**

![](./12.png)

![](./13.png)

![](./14.png)

**可重入(Reentrant)与线程安全**

一个函数要被重入只有两种情况:

1. 多个线程同时执行这个函数
2. 递归

一个函数要称为可冲入的必须有如下特点:

![](./15.png)

**过度优化**

过度优化的两种情况:

* 为了提高效率可能交换指令顺序
* 编译器在进行优化的时候,也可能为了效率而交换毫不相干的两条指令的执行顺序(x = 1 和 r1 = y)

```java
//指令交换例子
x = y = 0;
Thread1          	Thread2
x = 1;				y = 1;
r1 = y;				r2 = x;
//优化过后------------------
x = y = 0;
Thread1          	Thread2
r1 = y;				y = 1;
x = 1;				r2 = x;
```

**volatile**

* 阻止编译器为了提高速度将一个变量缓存到寄存器而不回写
* 阻止编译器调整操作volatile变量的指令顺序

**volatile只能阻止编译器为了提高效率而交换两条指令,但是无法阻止CPU动态调度换序**

```java
//例子
volatile T pInst = null;
T getInstace() {
    if(pInst == null) {
        lock();
        if (pInst == null) {
            pInst = new T();
        }
        unlock();
    }
    return pInst;
}
```

C++new的步骤

1. 分配内存

2. 调用构造函数

   pInst = new T 包含三个步骤

   1. 分配内存
   2. 在内存的位置上调用构造函数
   3. 将内存的地址赋值给pInst.

   在 2 , 3 的顺序是可以颠倒的, 有可能出现这样的情况:pInst的值已经不是NULL,但对象仍没有构造完毕. 这时候出现另外一个对getInstance的并发调用,此时第一个if内的表达式pInst== NULL,为false,所以这个调用会直接返回尚未完全的对象的地址(pInst) 以提供给用户使用. 那么程序这个时候会不会崩溃就取决于这个类如何设计.

CPU提供了**barrier(不同版本名称可能不一样)**指令可以阻止CPU将该指令前的指令交换到barrier之后.

##### 1.6.3 多线程内部情况

1. **一对一模型**
   1. 优点
      1. 用户线程和内核线程一致
      2. 线程之间的并发是真正的并发
   2. 缺点
      1. 许多操作系统限制了内核线程的数量,因此一对一线程会让用户的线程数量收到限制
      2. 许多操作系统内核线程调度时,上下文切换的开销较大,导致用户线程执行效率下降

![](./16.png)

1. **多对一模型**:将多个用户线程映射到一个内核线程上,线程切换代码由用户态代码进行

![](./17.png)

1. **多对多模型**:将多个用户态线程映射到少数但不知一个内核线程上

![](./18.png)

### 第二章编译和链接

#### 2.1 被隐藏了的过程

```c
gcc hello.c

./a.out //hello wintersweett
```

四个步骤

* 预处理(Prepressing)
* 编译(Compilation)
* 汇编(Assembly)
* 链接(Linking)

![](./1.png)

##### 2.1.1 预编译

```c
gcc -E hello.c -o hello.i  //-E 表示只进行预编译 cpp hello.c > hello.i
```

预编译主要规则:

![](./2.png)

##### 2.1.2 编译

> 编译过程就是把预处理完的文件进行一系列的词法分析,语法分析,语义分析及优化后生成的汇编代码文件.(核心部分,)

```c
gcc -S hello.i -o hello.s //现代版本的gcc将预处理和编译两个步骤合二为一了,所以可以直接调用一个命令
gcc -S hello.c -o hello.s
```

![](./3.png)

##### 2.1.3 汇编

> 汇编器是将汇编代码转变成机器可以执行的命令,每一个汇编语句几乎对应一条机器指令. 相对于编译器比较简单,没有语法,没有语义,不需要指令优化,只需要根据汇编指令和机器指令的对照表一一翻译即可.

```c
as hello.s -o hello.o
```

或者

```c
gcc -c hello.s -o hello.o
```

或者直接从C源代码文件开始进行 预编译->编译->汇编

```
gcc -c hello.c -o hello.o
```

##### 2.1.4 链接

> 把一些指令对其他符号地址的引用加以修正.

#### 2.2 编译器做了什么

> 编译器将高级语音翻译成机器语音的工具

编译过程:

1. 扫描
2. 语法分析
3. 语义分析
4. 源代码优化
5. 代码生成
6. 目标代码优化

![](./4.png)

##### 2.2.5 目标代码生成与优化

> 源代码级优化器产生中间代码. 编译器后端主要包括 代码生成器 和 目标代码优化器.  目标代码器对目标代码进行优化, 会选择合适的寻址方式,使用位移来代替乘法运算,删除多余指令等.

#### 2.3 链接器

**发展史**

在早期如果将所有的源代码都写在一个文件中.后期可能长达几百万行,基本上无法维护这个程序.

最开始人们通过一种卡带上面记录程序,(穿孔0,未穿孔1)每条指令是1个字节8位,如果一条跳转指令是高四位表示跳转,低四位表示跳转地址.0001 0100, 如果后期出现代码需要更新,新增了一条指令,那么这个绝对地址就需要改动,那么之前计算好的位置都需要重新计算,这个重新计算的工程被称为**重定位(Relocation)**

后来产生汇编语言, jmp 表示跳转指令 jmp foo  这个"foo"被称为**符号(Symbol)**

这个时候由于汇编语言的产生已经极大提高了生产力,代码量也快速膨胀,就导致人们开始考虑将不通功能的代码已一定的方式组织起来,以便于日后重复利用.源代码最小单位是变量和函数,若干的变量和函数就组成了一个".c"的文件,然后源码文件按照目录结构组织,每个基本类是一个模块,若干模块组成了一个**包(Package)**

#### 2.4 模块拼接--静态链接

链接的过程主要包括了

1. 地址和空间分配(Address and Storage Allocation)
2. 符号决议(Symbol Resolution)
3. 重定位(Relocation)

链接过程

![](./5.png)

备注.o文件拓展名为.o或.obj,笔记后面都把它叫做**中间目标文件** 简称**目标文件**

**用文字描述这个过程**

![](./6.png)

```c
//上面的话用.c文件举例
/**
现在有A.c B.c两个文件
B.c编译后有一条指令: 
mov1 $0x2a, var
这条指令就是给这个var变量赋值,var = 42 编译后的指令码:
c705 	00 00 00 00		2a 00 00 00
这个时候B在编译阶段并不能确定这个var变量的目标地址,所以在编译的时候将这个目标地址置为0,到了链接阶段,链接器将AB两个文件链接起来的时候再对这个0x42进行修正,假设A在编译后已经能确定地址值是0x1000 那么链接器会将这个 mov指令的目标地址修改承0x1000
/
```

上述这个修正的过程也叫作**重定位(Relocation)**,每个要被修正的地方叫一个**重定位入口**(Relocation Entry)

### 第三章 目标文件里面有什么

编译器编译源代码后生成的文件叫做**目标文件**,这个时候还没有进行链接的

目标文件从结构上它是已经编译后的可执行文件格式,其中有些符号或者地址还没调整

#### 3.1 目标文件的格式

PC平台流行的**可执行文件格式(Executable)** 主要是windows下的**(Portable Executable) **和Linux的**ELF(Executable Linkable Format)**, 都是COFF(Common file format)格式的变种.因为目标文件和可执行文件内容与结构很相似,所以一般更可执行格式一起采用一种格式存储. 从广义上讲目标文件与可执行文件格式几乎是一样的.

**动态链接库(DLL, Dynamic Linking Library)**(windows的.dll Linux的.so)以及**静态链接库(Static Linking Library)**(windows.lib  Linux.a)都是按照可执行文件格式存储

ELF格式的文件分类:

* 可重定位文件(.o   .obj)
* 可执行文件(/bin/bash   .exe)
* 共享目标文件(.so  dll)
* 核心转储文件(Linux 下的 core dump)

```c
file /bin/bash	//查看文件类型
```

![](./19.png)

#### 3.2 目标文件是什么样的

目标文件里面包含编译后的机器指令码,数据,链接时所需要的信息(符号表,调试信息,字符串),一般目标文件将这些信息按照不同的属性,以"**节(Section)**"的形式存储,有时候也叫"**段(Segment)**"

![](./20.png)

**目标文件包含的段**

* **File Header**: 描述了文件属性, 是否可执行,静态链接还是动态链接以及入口地址(可执行文件),目标硬件,目标操作系统信息,文件头里面还包含一个**段表(Section Table)**:描述文件中的各个段的数组
* **代码段.text**:机器码
* **数据段.data**已初始化的全局变量和局部静态变量
* **.bss**:为未初始化的全局变量和局部静态变量预留位置

**BSS(Block Started by Symbol)**

**总体上来说源代码被编译后主要分为两种段:   程序指令和程序数据**

分段的好处:

* 加载后,指令和数据会分别映射到两个不同的虚存区域,并且有可读可写与只读的权限划分,也可以防止程序指令被改写
* 指令和数据缓存分离,有利于提高CPU的缓存命中率
* 最重要的原因: 当系统中运行着多个该程序的副本是,因为指令都是一样的,所以内存中只需保存一份该程序的指令部分.因为是只读的,但是每个程序的数据是不一样的

page 84