# 深入理解计算机系统

## 第一章 计算机系统漫游

### 1.2 程序被其他程序翻译成不同的格式

![](./1.png)

![](./2.png)

### 1.4 处理器读并解释存储在内存中的指令

#### 1.4.1 系统的硬件组成

**1. 总线**

> 贯穿整个系统的是一组电子管道,称作总线,它携带信息字节并负责在各个部件间传递.  通常总线被设计成传送定长的字节快, 也就是字(word). 字中的字节数(字长)是一个基本的系统参数,大多数机器的字长要么是4字节(32位),要么是8个字节(64位)

**2. I/O设备**

![](3.png)

**3. 主存**

> 主存是一个临时存储社保,用来存放程序和程序处理的数据. 从物理上来说, 主存是由一组动态随机存储器(DRAM)芯片组成, 从逻辑上来说,存储器是一个线性的字节数组,每个字节都有其唯一的地址,这些地址是从零开始的. 组成程序的每条机器指令都由不同数量的字节构成.

**4. 处理器**

![](./4.png)

#### 1.4.2 运行hello程序

![](./5.png)

* 从键盘上读取hello命令
* 从磁盘加载可执行文件到主存
* 处理器还是执行hello程序的main程序中的机器指令语言指令,将"hello world\n"字符串中的字节从主存复制到寄存器,再从寄存器复制到显示设备

### 1.6 存储设备形成层次结构

![](./6.png)

### 1.7 操作系统管理硬件

操作系统基本功能:

* 防止硬件被失控的应用程序滥用
* 向应用程序提供简单一直的机制来控制复杂而又通常大不相同的低级硬件设备

操作系统通过几个基本的抽象概念(进程,虚拟内存和文件)来实现这两个功能.

#### 1.7.1 进程

**上下文: **操作系统保持跟踪进程运行所需的所有状态信息, 这种状态,被称为上下文.

![](./7.png)

#### 1.7.3 虚拟内存

> 虚拟内存是一个抽象概念, 它为每个进程提供了一个假象, 即每个进程都在独立地使用主存. 每个进程看到的内存都是一直的,称为**虚拟地址空间**

Linux虚拟地址空间分布:

![](./8.png)

![](./9.png)

虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互,包括对处理器生成的每个地址的硬件翻译. 基本思想是把一个进程虚拟内存的内容存储在磁盘是,然后用主存作为硬盘的告诉缓存.

#### 1.7.4  文件

> 每个I/O设备, 包括磁盘  键盘 显示器 网络都可以看成是文件

#### 1.9.2 并行和并发

![](./10.png)

#### 1.9.3 计算机系统中抽象的重要性

* 文件是对I/O设备的抽象
* 虚拟内存是对程序存储器的抽象
* 进程是对一个正在运行程序的抽象
* 虚拟机是提供对整个计算机的抽象

---

## 第二章 信息的表示和处理

```
ISO C99   >gcc -std=c99 prog.c	//指定C语音版本
ISO C11   >gcc -std=c11 prog.c
```

### 2.1 信息存储

> 计算机使用8位的块(字节byte),作为最小的可寻址的内存单位,  机器级程序将内存视为一个非常大的字节数组, 称为虚拟内存(virtual memory), 内存中的每个字节都由一个唯一的数字来标识 称为它的地址, 所有可能地址的集合都称为虚拟地址空间(Virtual Address Space)

#### 2.1.1 十六进制表示法

**当x是2的非负整数n次幂时 x=2<sup>n</sup>, n就可以表示成i + 4 j, 其中0≤i≤3, 可以把x写成开头的十六进制数字为1(i == 0), 2(i==1), 4(i == 2),8(i == 3), 比如x = 2048 = 2<sup>11</sup> 可以写成 n=11=3+4*2,那么十六进制就是0x800**

#### 2.1.2 字数据大小

```
gcc -m32 prog.c	//32位机器 64位都能运行
gcc -m64 prog.c	//64位机器
```

![](./11.png)

int32_t & int64_t 固定的4字节和8字节

![](./12.png)

#### 2.1.6 布尔代数简介

**位向量表示集合**

位向量a=[01101001] 表示集合 A= {0,3,5,6}

位向量b=[01010101] 表示集合B= {0,2,4,6}

取并集

​	01101001

& 01010101

​	01000001

a&b得到位向量01000001, 表示集合={0,6}

#### 2.2.3 补码编码

**机器数**

>一个数在计算机中的表现形式叫做机器数，这个数有正负之分，在计算机中用一个数的最高位（符号位）用来表示它的正负，其中0表示正数，1表示负数。

**真数**

> 计算机中的机器数对应的真实的值就是真数，对最高位（符号位）后面的二进制数转换成10进制，并根据最高位来确定这个数的正负。对于上面的00000111和10000111来说，对最高位后面的二进制数转换成10进制是7，在结合最高位的值，得出对应的真数分别是7和-7

**源码**:

> 用第一位表示符号，其余位表示值。因为第一位是符号位，所以8位二进制数的取值范围就是：[1111_1111 , 0111_1111]  即 [-127 , 127] ,原码是容易被人脑所理解的表达方式

**反码**

>正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反。例如正数1的原码是[0000_0001]，它的反码是是其本身[0000_0001],-1的原码是[1000_0001],其反码是[1111_1110]



**补码**

> 正数的补码是其本身，负数的补码是在其反码的基础上+1，例如正数1的原码是[0000_0001],他的补码是其本身[0000_0001],
>
> -1的补码是[1111_1111]

#### 2.2.2 无符号数的编码

一个整数数据类型有w位,可以写成  x(向量); 表示整个向量,或者可以写成[X<sub>w-1</sub>, X<sub>w-2</sub>,...,X<sub>0</sub>], 表示向量中都每一个位, 把x向量看做一个二进制表示都数,就获得了x向量的无符号表示,**每个位X<sub>i</sub>都为0或1**,

![](./22.png)

![1](./15.png)



#### 2.2.3 补码编码

![](./13.png)

![](./16.png)

```c
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
    size_t i;
    for (int i = 0; i < len; ++i) {
        printf(" %.2x", start[i]);
        printf("\n");
    }
}

int main() {
    short x = 12345;    //0011000000111001
    short mx = -x;      //1100111111000111  //-12345的补码
    show_bytes((byte_pointer) &x, sizeof(short));   // 39 30    小端
    show_bytes((byte_pointer) &mx, sizeof(short));  // C7 CF    小端
    return 0;
}
```

![](./14.png)

上图第二列是-12345的补码表示,当将进行T2U<sub>w</sub>会变成53191

无符号转换为有符号数:  函数 U2T<sub>w</sub>

有符号转换为无符号数:  函数 T2U<sub>w</sub>

T2U<sub>32</sub>(-1) = UMax<sub>32</sub> = 2<sup>32</sup> - 1 = 2<sup>31</sup> - 2 <sup>32</sup> = -2<sup>31</sup> = TMin<sub>32</sub>

在C语言里 有符号和无符号进行运算, C语言会隐式将有符号参数强制转换为无符号数



**二进制转补码B2T**

![](./17.png)

![](./18.png)

![](./19.png)

![](./20.png)

```
x		b        T2U4(x)
-8		1000		8
-3		1101		13
```

![](./23.png)

#### 2.2.5 C语言中都有符号数与无符号数

![](./21.png)

```c
x = -1; //二进制 11111111....1111 补码
//把-1 转换成无符号数 所以是 1x2(31) ... 2147..648
//将一个无符号数转换为补码会变成负数
    
```

#### 2.2.6 扩展一个数字都表示

无符号数的扩展: 高位补0

补码数的扩:  [X<sub>w-1</sub>,X<sub>w-1</sub>,X<sub>w-1</sub>,...]方式去填充,高位是啥就补啥

#### 2.2.7 截断数字

**截断无符号数字: 如果要将一个无符号数截断为K位, 直接 X mod 2<sup>k**</suP>

![](./24.png)

**截断补码数字: 如果要将一个补码截断为k位结果, 直接 X mod 2<sup>k</suP>, 然后再将结果转换为补码; 例如[1011 1101] 截取4位剩下[1101],转换成补码数 -1* 2<sup>k-1</sup> + 1* 2<sup>k-2</sup> + 1* 2<sup>0</sup> 结果为: -3;**

![](./25.png)



### 2.3 整数运算

> 假设一个4位数字表示, x= 9 y = 12; 和为21,表示为[10101]; 如果丢弃最高位就得到[0101] = 5 = 21 mod 16 = 5 ; 如果和的w+1表示最高位,如果是0表示不会溢出  如果是1表示溢出了, [10101]就溢出了

#### 2.3.2 补码加法

![](./31.png)

>解释推到过程:假设w=4   -7 + -7 = 1001 + 1001 =  9(T2U) + 9(T2U) = 18;   18 mod 2<sup>w</sup> = 2 = 0010;

#### 2.3.3 补码的非

![](./32.png)

![](./33.png)

> 理解:  k是最右边1的位置 ,那么将这个向量表示成[Xw-1,Xw-2,...,1,000],k左边的值按位取反,k不变

#### 2.3.4 无符号乘法

![](./40.png)

**无符号和补码乘法的位级等价性**

![](./41.png)

```
例如:  x = 1001 = -7   y = 0011 = 3; 无符号对应 x1 = 9, y1 = 3
x1 * y1 = 9 *3 = 27 = 0001 1011 ; -7 * 3 = -21  =  1110 1011; 
x1 * y1 = 3 * 9 mod 16 = 11 = 0000 1011;
截取后四位 = 1011;  
```

#### 2.3.5 补码乘法

补码的这两个两个数范围在-2<sup>w-1</sup> ~ 2<sup>w-1</sup> - 1内,那么他们的乘积取值范围就为-2<sup>2w-2</sup> + 2<sup>w-1</sup> ~ -2<sup>w-1</sup> * -2<sup>w-1</sup>  (如果w=4, 那么范围就是 -56 ~ 64); 

####  2.3.6 乘以常数

需要10个或者更多都时钟周期( 加法 减法 位级运算和移位 只需要1个时钟周期)

>有的编译器是可以将一些乘法转换成加法指令
>
>比如: 3 * 14  = 52
>
>编译器将14的二级制表达为一组01交替都序列; 14 = 01110,用n>= m表示这组连续的1的索引 , n = 3 ,m = 1; 则可以将乘积转换如下:
>
>x<<n + x<<(n-1)...+ x<<m = 3<< 3 + << 3 <<2 + << 3 << 1 +   <<
>
>11000 + 1100 + 110=24 + 12 + ...对不上

![](./42.png)

**偏置**: 比如我们要对一个小数转换成int,为了让这个值更精确采用四舍五入的方式, 比如99 50 = 1.98  转int = 1; 用(99 + 49) /50 = 2.96向下取整为2 ;  (x + (x<<k) -1) >> k ; k =4; x = 50; (50 + 15) / 16,让值更精确

![](./43.png)

#### 2.3.7 除以2的幂

整数除法需要30个或者更多都时钟周期

### 2.4 浮点数

![](./44.png)

![](./45.png)

#### 2.4.2 IEEE浮点表示

**IEEE(电子电器工程协会 eye-triple-ee)**

![](./46.png)

**NaN(Not a Number)**

![](./47.png)

**阶码:偏置形式表示的有符号整数: e是无符号数, Bias=2<sup>k-1</sup> -1 (单精度127,双精度1023)E = e - Bias; 那么单精度的取值范围是(-126 ~ + 127), 双精度的取值范围是: (-1022~+1023)** 

用一个例子来说明: 125.125D 在计算机里如何用二进制表示:

125 = [0111 1101] ; .125  可以用(1/8)表示 = 二进制的[001]

完整的二进制就表示为 1111101.001  = 1.111101001*2<sup>6</sup> 表示;

s: 0

**exp: e = ? - bias = 6:   最终填入exp里面的值就是 bias + 6 ;**

frac:111101001

对应如何填入到格式: 

31   -     30 		-		23						-				0

0 			1000 0101    11110100100000000000000

例子2:12345 = [11000000111001] = 1.1000000111001 * 10 <sup>13</sup>

s: 0;

exponent: 13 + 127 = 140 = [10001100]

fraction: 10000001110010000000000

结果:[0|10001100|10000001110010000000000]

## 第三章 程序的机器级表示

汇编代码是机器代码的文本表示

### 3.2 程序编码

```c
linux> gcc -Og -o p p1.c p2.c		
```

**-Og: **告诉编译器使用会生成复合原始C代码整体结构的机器代码的优化等级

实际中,从得到的程序性能考虑,较高级别的优化(**-O1和-O2(优化等级)**)被认为是较好的选择

**编译步骤**

* C预处理器:	扩展源代码,插入所有用#include命令指定的文件,并扩展所有#define声明指定的宏
* 编译器:     产生两个源文件的汇编代码p1.s p2.s
* 汇编器:     会将汇编代码转化成二进制目标代码文件p1.o 和p2.o, 目标代码是机器代码的一种形式, 它包含所有指令的二进制表示
* 链接器:     将两个目标代码文件与实现函数库(stdio.h)的代码合并,并产生最终可执行代码文件

#### 3.2.1 机器及代码

**计算机系统最重要的两种抽象形式: **

* **指令集体系结构或指令集架构(Instruction Set Architecture,ISA)来定义机器级别程序的格式和行为,定义类处理器状态, 指令的格式,每条指令对状态的影响**
* **机器级程序使用内存地址是虚拟地址,提供的内存模型看上去是一个非常大的字节数组,存储器系统的实际实现是将多个硬件存储和操作系统软件组合起来.**

会用到的源码:

```c
long mult2(long,long);

void multstore(long x, long y, long* dest) {
	long t = mult2(x,y);
    *dest = t;
}
```

```
linux> gcc -Og -S mstore.c		//生成汇编代码linux> gcc -Og -c mstore.c		//编译汇编生成目标代码文件(二进制格式)linux> objdump -d mstore.o		//通过反汇编器将机器代码产生一种类似于汇编代码格式.
```

![](./48.png)

#### 3.2.2 代码示例

需要注意机器代码和它的反汇编表示的特性值:

* x86-64 的指令长度从1-15个字节不等.常用的指令以及操作数较少的指令所需要的字节数少, 反之会字节数较多
* 设计指令格式的方式是,从某个给定位置开始,可以将字节唯一地解码成机器指令
* 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码. 不需要访问该程序的源代码或汇编代码
* 反汇编器使用的指令命名规则与GCC生成的汇编代码有细微差别,gcc会省略"q",反汇编器会加上"q" 例如 call ret

#### 3.2.3 关于格式的注解

![](./49.png)

pushq %rbx	:	表示应该将寄存器%rbx的内容压入到程序栈中.

```
linux> gcc -Og -S -masm=intel mstore.c	//可以得到Intel格式汇编代码
```

**如何在C语言中插入汇编代码**

* 编写完整的函数,放进一个独立的汇编代码文件中,让汇编器和链接器把它和.c源代码合并.
* 用GCC的内联汇编特性, 用asm伪指令可以在C程序中包含简短的汇编代码

### 3.3 数据格式

> Intel用术语"字()word"表示16位数据类型, 32位数位"双字(double words)", 64位数位"4字(quad words)" 64位机器指针占用8字节

![](./50.png)

例如:movb(传送字节) movw(传送字) movl(传送双字) movq(传送四字)

### 3.4 访问信息

**x86-64的CPU包含一组16个存储64位值的通用目的寄存器,用来存储整数数据和指针**

常用:

1. %rax:	 返回值
2. %rbx:     被调用者保存
3. %rcx:     第四个参数
4. %rbp:     被调用者保存
5. %rsp:     栈指针
6. %rsi:      第二个参数
7. %rdi:      第一个参数
8. %r10-%r15:      调用者保存

![](./51.png)

对于生成小于8字节结果的指令,寄存器中剩下的字节遵循两条规则:

* 生成1字节和2字节数字的指令会保持剩下的字节不变; 
* 生成4字节数字的指令会把高位4个字节置为0

#### 3.4.1 操作数指示符

操作数可以分位三种类型:

* 立即数(immediate),用来表示常数值; 书写方式"$"后面跟一个用标准C指示法表示的整数
* 寄存器(register),表示某个寄存器的内容.16个寄存器的低位1,2,4,8中的一个作为操作数
* 内存引用: 会根据计算出来的地址,访问某个内存位值.M[addr]访问内存中的字节

![](./34.png)

#### 3.4.2 数据传送指令

MOV类 把数据从源位值复制到目的位值, 区别在于传送数据大小不同:

* movb : 	1字节
* movw:      2字节
* mov1:       4字节
* movq:       8字节

传送指令的两个操作数不能都指向内存位值: 只能拆分成两条指令,将原值加载到寄存器,第二条指令将寄存器的值写入目的地址

![](./52.png)

MOVZ: 把目的中剩余的字节填充为0

MOVS:通过符号扩展来填充(将最高位进行复制)

#### 3.4.3 数据传送示例

```c
long exchange(long *xp, long y) {
    long x = *xp;
    *xy = y;
    return x;
}
//对应的汇编指令
xp in %rdi, y in %rsi
exchange:
	movq (%rdi),%rax;	//(%rdi) 取指针指向的值 x = *xp
	movq %rsi,(%rdi);  	//*xp = y
	ret 
```

#### 3.4.4 压入和弹出栈数据

> 栈向下增长,栈顶元素的地址是所有栈元素地址中最低的

```
栈底  
0xFFFFFF;
0xFFFFF7;
0xFFFFF0
栈顶
```

* pushq把数据压栈 (两条指令: subq $8,%rsp, movq%rbp,(%rsp))
* popq出栈(两条指令: movq(%rsp), %rax; addq $8, %rsp)

### 3.5 算术和逻辑操作

加法指令分类:

- addb 字节加法
- addw 字加法
- addl   双字加法
- addq  四字加法

指令分组:

- 加载有效地址
- 一元操作
- 二元操作
- 位移

#### 3.5.3 移位操作

* **左指令只有两个名字SAL和SHL,都是右边补0**
* **右移指令分为SAR算术位移(填上符号位),SHR逻辑位移(补0)**

![](./69.png)

**以下是128位数字运算在汇编的表示**

```c
void store_uprod(uint128_t *dest, uint64_t x, uint64_t y) {
    *dest = x * (uint128_t) y;
}
```

![](./70.png)



### 3.6 控制

#### 3.6.1 条件码

* CF: 进位标志
* ZF: 零标志 zero flag
* SF: 符号标志 sign flag
* OF: 溢出标志 over flag

#### 3.6.4 跳转指令的编码

![](./55.png)

上图汇编代码解释: jmp 8 = 03 + 05 执行test  ,接着下一行跳转指令 jg .L3 5 = f8 + b  = 5 = -8 + 13得出L3的地址

* jmp *%rax: 用寄存器%rax中的值作为跳转目标
* jmp *(%rax): 以%rax中的值作为读地址,从内存中读出跳转目标



#### 3.6.5 条件控制

![](./57.png)

#### 3.6.6 用条件传送实现条件分支

![](./56.png)

3-17c的汇编代码第七行是一条基于条件传送的指令,对比3.6.5的条件控制性能更好, 处理器不需要预测测试都结果就可以执行条件传送. 条件控制面临预测失败的风险.  **使用条件传送也不总是会提高代码效率,因为then-expr或else-expr需要大量的计算,如果相应条件又不满足就浪费了计算资源. GCC只有当两个表达式都很容易计算时,它才会使用条件传送**

举例:

```
v = test-expr ? then-expr : else-expr;
//条件控制实现
    if(!test-expr) 
        goto false;
    v = then-expr;
    goto done;
false:
	v = else-expr;
done:

//条件传送实现;
v = then-expr;
ve = else-expr;
t = text-expr;
if(!t) v= ve;
```

#### 3.6.7 循环

* do{...} while()
* while
* for

GCC为for循环生成的代码是while循环的两种翻译之一,取决于优化等级

```c
//  goto 方式  
	init-expr;
    goto test;
loop:
	body-statement
    update-expr;
	if(t) 
        goto loop;

//guarded-do方式
	init-expr;
	t = test-expr;
	if (!t) 
        goto done;
loop:
	body-statement
    update-expr;
	if(t)
        goto loop;
done;
```





#### 3.6.8 switch 语句

![](./58.png)

上面这段话总结下来表达了两个点:

1. switch性能优于开关语句(if-else):  使用跳转表这种数据结构,case对应都就是其代码段的地址.
2. GCC在编译时会根据if-else的数量来决定是否要将其转换为switch结构

![](./59.png)

![](./60.png)

**表声明在".rodata"字段**

### 3.7 过程

> 过程是软件中一种很重要的抽象. 它提供了一种封装代码的方式, 用一组指定都参数和一个可选都返回值实现了某种功能. 然后可以在不同都地方调用这个函数.

过程都表现形式:

* 函数(function)
* 方法(method)
* 子例程(subroutine)
* 处理函数(handler)

#### 3.7.2 转移控制

> 比如函数P调用函数Q,只需要把程序计数器(PC)设置为Q的代码的起始位置. 从Q发挥都时候处理器必须记录好它接下来需要继续执行P的执行代码位置.在x86-64中,调用call Q指令时,会将callQ下面的一条指令压栈, 接着改变%rsp(栈顶) 和 %rip(程序计数器)的值, 当函数Q结束的调用ret指令,这时候会将程序计数器%rip的值改变为call Q函数的下一条指令的值,这时程序接着 函数P的下一条指令开始执行

![](./61.png)

#### 3.7.3 数据传送

> 当调用一个函数时,可以通过寄存器传递, 首先将参数复制到寄存器, P代码就可以通过访问寄存器里都值, 寄存器最多传递6个整型(整数和指针),  寄存器是有特殊顺序都, 使用的寄存器名字需要取决于数据类型的大小, 如果超出6个参数, 则需要通过栈传递. 通过栈传递的时候所有都数据大小都向8的倍数对齐.并且栈需要扩容

![](./62.png)

![](./63.png)

可以看到proc方法一共有8个参数,在红框的位置通过rsp+16来得到剩下两个参数的地址;  可以通过%rsp-8的方式得到

#### 3.7.4 栈上都局部存储

![](./64.png)

这个图主要是说明当一个局部变量的参数涉及到指针地址传递的时候需要开辟栈空间的这样才能获取到地址

**特殊情况局部数据必须存放在内存中:**

* 寄存器不足够存放所有的本地数据
* 对一个局部变量使用地址运算符"&", 因此必须能够为它产生一个地址
* 某些局部变量是数组或结构,因此必须能够通过数组或结构引用被访问到.

#### 3.7.5 寄存器中都局部存储空间

#### 3.7.6 递归过程

### 3.8 数组分配和访问

#### 3.8.1 基本原则

数据类型T和整型常数N,声明

T A\[N];

* X<sub>A</sub>: 起始位置
* L : 数据类型T的大小(单位为字节)
* A : 标识符,可以用A来作为指向数组开头都指针, 指针的值为X<sub>A</sub>
* 数组元素i会被存放在X<sub>A</sub> + L * i 的位置

#### 3.8.2 指针运算

单操作数操作符'&'和'*' 可以产生指针和间接引用指针, 表达式Expr 与 * &Expr是等价的, 数组引用A[i] = *(A+ i)

![](./65.png)

#### 3.8.3 嵌套的数组

T D\[R]\[C];对应都数组元素D\[i]\[j]的内存地址为:

&D\[i]\[j] = X<sub>D</sub> + L(C* i + j)

### 3.9 异质的数据结构

C语言提供了两种将不同类型都对象组合到一起创建数据类型的机制:

* 结构(structure)
* 联合(union)

#### 3.9.1 结构

> 将不同类型的对象聚合到一个对象中,用名字来引用各个组成部分,类似于数组的实现.结构的左右组成部分都存放在内存中一段连续的区域内,而指向结构的指针就是结构第一个字节的地址. 编译器维护关于每个结构类型信息,指示每个字段(field)的字节偏移.

```c
struct rect {
    long llx;
    long lly;
    unsigned long width;
    unsigned long height;
    unsigned color;
}
struct rect = {0,0,10,20,0XFF00FF};	//声明并初始化
```

![](./66.png)

#### 3.9.2 联合

```c
struct S3{
	char c;
	int i[2];
    double v;
}

union U3{
	char c;
	int i[2];
    double v;
}
```

> 一个联合的总的大小等于它最大字段的大小

#### 3.9.3 数据对齐

**计算机系统对基本数据类型的合法地址做了一些限制, 要求某种类型对象的地址必须是某个值K(通常是2,4,8)的倍数.  这种对齐简化了形成处理器和内存系统之间接口的硬件设计;**  例如, 假设一个处理器总是从内存中取8个字节,则地址必须为8的倍数,那么就可以用一个内存操作来读或者写值, 否则可能需要执行两次内存访问,因为对象可能被分钟两个8字节内存块中

```
.align 8 //汇编代码看到这种命令,保证它后面的数据是8的倍数.
```

![](./67.png)

```c
struct S2{
    int i;
    int j;
    char c;
}
//这种结构会采用尾部对齐,填充3个字节  总大小为12个字节
```

### 3.10 在机器级程序中将控制与数据结合

#### 3.10.1 理解指针

指针特性:

* 每个指针都对应一个类型

* 每个指针都有一个值

* 指针用"&"运算符创建

* *操作符用于间接引用指针

* 数组与指针紧密联系

* 将指针从一种类型转换成另一种类型,只改变它的类型,而不改变它的值. **强制类型转换的一个效果是改变指针运算的收缩**例如p是一个char\*类型的指针,它的值为p, 那么(int\*)p+7 = p+ 28; 而(int\*)(p+7) = p+7.

* 指针也可以指向函数

  ```c
  int fun(int x, int *p);
  
  int (*fp)(int,int*);
  fp = fun;
  
  // use
  int y = 1;
  int result = fp(3,&y);
  ```

  函数指针的值是该函数机器代码表示中第一条指令的地址

#### 3.10.2 应用: 使用GDB调试器

#### 3.10.3 内存越界引用和缓冲区溢出

缓冲区溢出后会破坏程序的信息; 比如输入一个字符串是24字节,那么其他地址就会有其他的作用,当输入内容超出了24字节,就会覆盖栈上存储 的某些信息

#### 3.10.4 对抗缓冲区溢出攻击

**1. 栈随机化: ** 以往程序都栈地址非常容易预测.对于所有运行同样程序和操作系统版本系统来说, 在不同机器之间, 栈的位置相对固定的.攻击者既要插入代码,也要插入指向这段代码的指针.**随机化**使栈的位置在程序每次运行时都有变化,  实现方式是:  程序开始时, 在栈上分配一段0~n字节之间都随机大小的空间, 分配的范围n必须足够大,才能获得足够多的栈地址变化,但是又要足够小,不至于浪费程序太多的空间

**2. 栈破坏检测: 加入了一种栈保护者机制,来检测缓冲区越界**

![](./68.png)

**3. 限制可执行代码区域**限制哪些内存区域能够存放可执行代码.在典型程序中,只有保存编译器产生的代码那部分内存才是需要执行的,其他部分可以被限制只允许读写.

#### 3.10.5 支持变长栈帧

> x86-64代码使用寄存器%rbp作为帧指针(frame pointer)(优势称为基指针(base pointer)), %rbp中bp的由来.

### 3.11 浮点代码

> Intel 和 AMD都引入了媒体指令,支持图形和图像处理. 这些指令本意是允许多个操作以并行模式执行.称为**单指令多数据或SIMD(sim-dee)**

* 寄存器组在MMX 中称为"MM"寄存器 64位
* SSE(流式SIMD扩张)中称为"XMM"寄存器  128位
* AVX(Advanced Vecotr Extension)中称为"YMM"寄存器  256位

**标量指令:**他们只对单个而不是一组封装好的数据值进行操作.数据要么保存在内存中(M32, M64)指明,要么保存在XMM寄存器中.

### 3.2.12 小结

Java的目标代码是一种特殊的二进制表示,称为java字节码. 这种代码可以看成是虚拟机的机器级程序.正如它的名字暗示的那样, 这种机器并不是直接用硬件实现的,而是用软件解释器处理字节代码模拟虚拟机的行为.

---

## 第四章 处理器体系结构

指令被编码为由一个或多个字节序列组成的二级制格式.一个处理器支持的指令和指令的字节级编码称为它的**指令集体系结构(Instruction-Set Architecture, ISA)**

### 4.1 Y86-64指令集体系结构

#### 4.1.2 Y86-64指令

* x86-64 的movq指令分成了不同指令:irmovq,rrmovq,mrmovq,rmmovq,立即数(i),寄存器(r),内存(m),第一个字母是源的类型,目的的是寄存器(r),内存(m)

![](./71.png)

![](./79.png)

**rA,rB : **寄存器指示符字节(register specifier byte),指定一个或两个寄存器,根据指令类型,可以指定用于数据源和目的的寄存器,或是用于地址计算的基址寄存器.如果只需要一个寄存器,那么另一个会设置成0xF

#### 4.1.3指令编码

每条指令需要1~10字节不等.**每条指令的第一个字节表明指令的类型. 这个字节分为两个部分,每部分4位: 高4位是代码部分,第四位是功能部分, 也就是上图的fn位置**

![](./72.png)

例如: 用十六进制来表示指令rmmovq %rsp, 0x123456789abcd(%rdx)的字节编码, (rmmovq rA,D(rB))第一个字节为40,源寄存器%rsp 与目标寄存器%rdx 42, 如果采用小端表示二进制编码为: 4042cdab896745230100

**指令集的一个重要性质就是字节编码必须有唯一的解释. 任意一个字节序列要么是一个唯一的指令序列编码,要么就不是一个合法的字节序列, 因为每条指令的第一个字节有唯一的代码和功能组合,给定这个字节,我们就可以决定所有其他附加字节的长度和含义. 这个性质保证了处理器可以无二义性地执行目标代码程序. 即时代码嵌入在程序的其他字节中,只要从序列的第一个字节开始处理, 我们仍然可以很容易地确定指令序列. 如果不知道一段代码序列的起始位置,就不能准确地确定怎样将序列划分成单独的指令**

**RISC 和 CISC 指令集**

* x86-64 有时被称为 "复杂指令集计算机" CISC sisk;
* 精简指令集计算机 RISC risk
* ARM(Acorn RISC Machine)

#### 4.1.4 Y86-64 异常

![](./73.png)

### 4.2 逻辑设计和硬件控制语言HCL

**硬件控制语言HCL(Hardware Control Language)**

#### 4.2.2 组合电路和HCL布尔表达式

将很多逻辑门组合成一个网,就能构建计算快(computational block), 称为组合电路(combinational circuits). 构建限制

* 每个逻辑门的输入必须连接到以下选项之一:
  * 一个系统输入(主输入)
  * 某个存储器单元的输出
  * 某个逻辑门的输出
* 两个或多个逻辑门的输出不能连在一起,否则他们可能会使线上的信号矛盾,可能会导致一个不合法的电压或电路故障
* 这个网必须是无环的. 在网中不能有路径经过一系列门而形成一个回路.

**多路复用器(multiplexor, 用"MUX"简写)**

**算术/逻辑单元(ALU)**

![](./74.png)

#### 4.2.5 存储器和时钟

![](./75.png)

![](./76.png)

![](./77.png)



![](./78.png)

### 4.3 Y86-64 的顺序实现

**SEQ("sequential"顺序的)处理器**

#### 4.3.2 SEQ硬件结构

Y86-64所需要的计算拆分成6个基本阶段:**取指,译码,执行,访存,写回,更新PC**

* **取指**(fetch): 取指阶段从内存读取指令字节,地址为程序计数器(PC)的值. 从指令中抽取出指令指示符字节的两个思维部分,称为icode(指令代码)和ifun(指令功能), 可能取出一个寄存器指示符字节 指明一个或两个寄存器操作数指示符rA,rB.还可能取出4字节常数valC,它按顺序方式计算当前指令的下一条指令的地址valP,也就是说**valP等于PC的值加上已取出指令的长度**将程序计数器寄存器作为地址,指令内存读取指令字节,PC增加器(PC incrementer)计算valP

* **译码**(decode):从寄存器文件读入最多两个操作数,得到值valA和valB,通常它读入指令rA和rB字段指明的寄存器.  寄存器文件有两个读端口A和B,从这两个端口同时读寄存器值valA 和valB

* **执行**(execute):根据指令类型,将算术/逻辑单元(ALU)用于不通的目的,对整数操作,要执行指令所指定的运算. 对于其他指令,会作为一个加法器来计算增加或减少栈指针,或计算有效地址.

  条件码寄存器(CC) 有三个条件码位,ALU负责计算条件码新值.当执行条件传送指令时,根据条件码和传送条件来计算决定是否更新目标寄存器.  当执行一条跳转指令时,会根据条件码和跳转类型来计算分支信号Cnd.

* **访存**(memory): 访存阶段可以将数据写入内存,或者从内存读出数据,读出的值为valM,     在执行访存操作时, 数据内存读出或写入一个内存字. 指令和数据内存访问的是相同的内存位值,但是用于不同的目的.

* **写回**(write back):寄存器文件有两个写端口,端口E用来写ALU计算出来的值,端口M用来写从数据内存中读出的值

* **PC更新**:程序计数器的新值选择自: valP: 下一条指令的地址; valC: 调用指令或跳转指令指定的目标地址; valM:从内存读取的返回地址.

![](/80.png)

![](./81.png)

**"←"表示一个分配操作符**

todo

### 4.4 流水线的通用原理

> 流水线提高了系统的吞吐量(throughput), 也会轻微地增加延迟(latency)

#### 4.4.1 计算流水线

![](./83.Png)

* 电路延迟以微微秒或皮秒(picosecond,ps), 10<sup>-12</sup>秒为单位来计算.

![](./84.png)

**以下的计算都会以每秒千兆条指令(GIPS),也就是每秒十亿条指令为单位来计算吞吐量,从头到尾执行一条指令所需要的时间成为延迟(latency)**

![](./85.png)

如果不采用流水线一条指令的执行时间是320ps,吞吐量约为3.12GIPS,如果采用流水线,将时钟周期设置为120ps,吞吐量大约为8.33,一条指令需要3个时钟周期,所以流水线的延迟就是3x120=360ps,吞吐量提高了2.67倍,延迟增加了(360/320=1.12)

#### 4.4.3 流水线的局限性

**1.不一致的划分**

运行时钟的速率是由最慢的阶段的延迟限制的.

**2.流水线过深,收益反而下降**

![](./86.png)

上图系统的最小时钟周期为50+20=70ps,吞吐量为14.29GIPS,相对于4.4.1的流水线阶段数来说增加了2被,性能提高了14.29/8.33=1.71倍.延迟=420ps,

**为了提高时钟频率,现代处理器采用了很深的(15或更多的阶段)流水线.处理器架构师将指令的执行划分成很多非常简单的步骤,这样一来每个阶段的延迟就很小.**

----

## 第五章 优化程序性能

**编写高效程序需要做到几点:**

- **选择一组适当的算法和数据结构**
- **编写出编译器能够有效优化以转换成高效可执行代码的源代码**
- **对处理运算量特别大的计算,将一个任务分成多个部分**

### 5.1 优化编译器的能力和局限性

并非所有函数都能优化.例如:

```c
void twiddle1(long *xp, long *yp) {
    *xp += *yp;
    *xp += *yp;
}

void twiddle2(long *xp, long *yp) {
    *xp += 2 * *yp;
}
```

函数`twiddle2`效率更高,它只要求3次内存引用(读*xp, 读*yp, 写*xp), `twiddle1`需要6次(2次读\*xp,2次读\*yp,2次写\*xp)

如果xp等于yp的情况,`twiddle1`是xp增加了4倍,`twiddle2`增加3倍

类似例子例如:

```c
long f();
long func1(){
    return f() + f() + f() + f();
}

long func2() {
    return 4 * f();
}
//如果f函数是这样:
long counter = 0;
long f() {
    return counter++;
}
//func1 = 6;
//func2 = 0;
```

### 5.2 表示程序性能

表示程序性能并指导改进代码的方法表示:**每元素的周期数(Cycles Per Element, CPE)**

处理器活动顺序是由时钟控制的,时钟提供了某个频率的规律信号,通常用**千兆赫兹(GHz),即十亿周期每秒来表示**,例如4GHz表示处理器时钟运行频率为每秒4x10<sup>9</sup>个周期.一个4GHz的时钟周期为0.25纳秒,或者250皮秒.

### 5.3 程序示例

在一个具有Intel Core i7 Haswell 处理器的机器上测量这些函数的CPE性能,这个机器称为**参考机**

![](./87.png)

```c
void combine1(vec_ptr v, data_t *dest) {
    long i;
    *dest = IDENT;
    for(i = 0; i < vec_length(v); i++) {
        data_t val;
        get_vec_element(v, i, &val);
        *dest = *dest OP val;
    }
}

//优化
void combine2(vec_ptr v, data_t *dest) {
    long i;
    *dest = IDENT;
    
    long length = vec_length(v);
    
    for(i = 0; i < length; i++) {
        data_t val;
        get_vec_element(v, i, &val);
        *dest = *dest OP val;
    }
}
```

![](./88.png)

### 5.5 减少过程调用

```c
void combine3(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    data_t *data = get_vec_start(v);
    
    *dest = IDENT;
    for(i = 0; i < length; i++) {
        *dest = *dest OP data[i];
    }
}

data_t *get_vec_start(vec_ptr v) {
    return v->data;
}
```

![](./89.png)

### 5.6 消除不必要的内存引用

![](./90.png)

性能浪费在1,3行,将内存里面的值读出保存到寄存器,第三行将寄存器的结果写入到内存.

优化后:

![](./91.png)

![](./92.png)

### 5.7 理解现代处理器

两种下界描述了程序的最大性能:

* **当一系列操作必须按照严格顺序执行时,会遇到延迟界限(latency bound),在下一条指令开始之前,这条指令必须结束.当代码中的数据相关限制了处理器利用指令集并行能力时,延迟界限能够限制程序性能**
* **吞吐量界限(throughput bound)刻画了处理器功能单元的原始计算能力,这个界限是程序性能的终极限制**

#### 5.7.1 整体操作

* 指令控制单元(Instruction Control Unit, ICU)
* 执行单元(Execution Unit,EU)
* 分支预测(branch prediction)
* 投机执行(speculative execution),处理器会开始取出位于它预测的分支会跳转到的地方的指令,并对指令译码,甚至在它确定分支预测是否正确之前就开始执行操作,只是最后确定分支预测错误,会将状态设置到分支点的状态,并开始取出和执行另一个方向上的指令

**Intel Core i7 Haswell功能单元**

![](./93.png)

### 5.8 循环展开

![](./94.png)

### 5.9 提高并行性

![](./95.png)

多个累积变量

### 5.13 应用: 性能提高技术

1) 高级设计. 为遇到的问题选择适当的算法和数据结构
2) 基本编码原则,避免限制优化的因素, 让编译器产生高效的代码
   * 消除连续的函数调用
   * 消除不必要的内存引用
3) 低级优化,结构化代码可以利用硬件功能
   - 展开循环,降低开销
   - 通过使用例如过个累积变量和重新结合等技术,找到方法提高指令集并行
   - 用功能性的风格重写条件操作,是的编译采用条件数据传送

在为了提高效率重写程序时避免引入错误, 因为在引入新变量,改变循环边界会使得代码整体上更复杂,很容易犯错误. 意向游泳的技术是在优化函数时,用检查代码来测试函数的每个版本,乙炔表在这个过程没有引入错误

### 5.14 确认和消除性能瓶颈

主要讲了调试器

---

## 第六章 存储器层次结构

### 6.1 存储技术

#### 6.1.1 随机访问存储器

**1.静态RAM(Static Random-Access Memory,)**

**2.动态RAM(Dynamic Random-Access Memory)**

**3.传动DRAM**

![](./96.png)

解释上图: 为了读出超单元(i,j)的内容,内存控制器将行地址i发送到DRAM, 然后是列地址j,行地址称为**RAS(Row Access Strobe 行访问选通脉冲)**请求,列地址j称为**CAS(Column Access Strobe, 列访问选通脉冲)**, 将读取的一行放入行缓冲区,随后列读取返回

**4.内存模块**

#### 6.1.2 磁盘存储

![](./97.png)

![](./98.png)

**磁盘一扇区大小的块来读写数据. 对扇区的访问时间*(access time)有三个部分:寻道时间(seek time),旋转时间(rotational latency)和传送时间(transfer time):**

* **寻道时间:**为了读取某个目标扇区的内容,传动臂首先将读/写头定位到包含模板扇区的磁道上.移动传动臂所需的时间称为寻道时间
* **旋转时间**:当读/写头定位到了期望的磁道,驱动器等待模板扇区的第一个位旋转到读/写头下. 这个步骤性能依赖于当读/写头到达模板扇区时盘面的位置以及磁盘的旋转速度. 最坏情况读写头刚错过了目标三区,必须等待磁盘转一整圈.
* **传送时间:**当目标扇区的第一个位位于读/写头下时, 驱动器就可以开始读写该扇区的内容,一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目

**4.逻辑磁盘块**

磁盘封装中有一个小的固件设备,称为磁盘控制器,维护着逻辑块号和实际(物理)磁盘扇区之间的映射关系,当操作系统想要执行一个I/O操作时, 操作系统会发送一个命令到磁盘控制器,让它读某个逻辑块号.控制器上的固件执行一个快速表查找,将一个逻辑块号翻译成一个(盘面,磁道,扇区)的三元组.这个三元组标识了唯一一个物理扇区

**5. 连接I/O设备**

显卡,显示器,鼠标,键盘,磁盘这类都是通过I/O总线,外围设备互联(Peripheral Component Interconnect,PCI)总线连接到CPU和主存.

三种不同类型的设备连接到总线:

* 通用串行总线(USB)
* 图形卡
* 主机总线

![](./99.png)

直接访问主存(Direct Memory Access, DMA) 不需要经过CPU

> 描述读取过程: 假设磁盘控制器映射到端口0xa0; 随后CPU可能通过执行三个对地址0xa0的存储指令,发起磁盘读: 第一条指令发送一个命令字,告诉磁盘发起一个读,同时还发送其他的参数(例如,读完成时是否中断CPU), 第二条指令指明应该读的逻辑块号. 第三条指令指明应该存储磁盘扇区内容的主存地址.  当磁盘控制器收到CPU读的指令后, 它将逻辑块号翻译成一个扇区地址,读该扇区的内容,然后将这些内容直接传送到主存.在DMA传送完成,磁盘扇区内容被安全的存储在主存以后,磁盘控制器通过给CPU发送一个中断信号来通知CPU. 其基本思想史中断会发信号到CPU芯片的外部引脚上, CPU会暂停当前的工作跳转到一个操作系统例程, 这个程序会记录下IO已经完成,然后将控制返回到CPU被中断的地方

![](./100.png)

#### 6.1.3 固态硬盘

固态硬盘(Solid State Disk, SSD), 固态硬盘打印进行100000次重复写之后,块就会磨损坏,一旦磨损坏之后就不能再使用了, 闪存翻译层中的平均磨损逻辑试图通过讲擦除平均分布在所有的块上来最大化每个块的寿命.

![](./101.png)

### 6.2 局部性

倾向于引用邻近于其他最近引用过的数据项的数据项,或者最近引用过的数据项本身.这种倾向性,被称为**局部性原理(principle of locality)**,

局部性的两种形式:

* 时间局部性(temporal locality): 被引用过一次的内存位置很可能在不远的将来再被多次引用.
* 空间局部性(spatial locality): 如果一个内存位置被引用了一次,那么程序很可能在不远的将来引用附近的一个内存位置

#### 6.2.3 局部性小结

量化评价程序中局部性的一些简单原则:

* 重复引用相同变量的程序有良好的时间局部性.
* 对于步长为k的引用模式的程序,步长越小,控件局部性越好.
* 对于取指令来说,循环有好的时间和空间局部性,循环体越小,循环迭代次数越多,局部性越好.

### 6.3 存储器层次结构

![](./102.png)

数据总是以块为**传送单元(transfer unit)**在第k层和k+1层之间来回赋值的. 存储器层次结构的本质是**每一层存储设备都是较低一层的缓存**

![](./103.png)

![](./104.png)

高速缓冲确定一个请求是否命中,抽取出被请求的过程分为三步:

1. 组选择
2. 行匹配
3. 字抽取

![](./105.png)

![](./106.png)

100:偏移量,表示从第四个字节开始

当不命中时会从存储器层次结构中的下一层取出被请求的块, 然后将新的块存储在组索引位指示组中的高速缓存行中,如果已经填充满了,这时会驱逐出一个现存的行

![](./107.png)

#### 6.4.5 有关写的问题

高速缓冲读的操作: 	首先在高速缓存中查找所需字w的副本, 如果命中,立即返回w给CPU, 如果不命中,从存储器层次结构中较低层取出含字w的块,将这个块存储到高速缓存行中.然后返回字w

写操作:   当要写一个已经缓存了的字w在高速缓存更新了w副本后,  立即将w的高速缓存快写回到紧接着低一层中(直写 write-through),  但是带来的缺点是每次写都会引起总线流量,  另一种方式是写回(write-back),尽可能地推迟更新, 只有当替换算法要驱逐这个更新过的块时,才把它写回低一层中. 缺点是增加了复杂性, 高速缓存必须为每个缓存行维护一个额外的修改位,表明是否被修改过.

处理写不命中: 	写分配(write-allocate),加载相应的低一层中的块到高速缓存中,然后更新这个高速缓存块.  写分配试图利用写的空间局部性,缺点是每次不命中都会导致一个块从低一层传送到高速缓存.

![](./108.png)

### 6.5 编写高速缓存友好的代码

* 对局部变量的反复引用是好的(时间局部性)
* 步长为1的引用模式是好的,存储器层次结构中所有层次桑的缓存都是将数据存储为连续的块(空间局部性)

#### 6.6.3 在程序中利用局部性

推荐:

* 将注意力集中在内循环上,大部分计算和内存访问都发生在这里
* 通过按照数对象存储在内存中的顺序,步长为1的来读数据,从而使程序中的空间局部性最大
* 一旦从存储器读入了一个数据对象,就尽可能多使用它,从而使得程序中的时间局部性最大

---

## 第七章 链接

### 7.1 编译器驱动程序

运行示例:

```c
//main.c
int sum(int *a, int n);
int array[2] = {1,2};
int main() {
    int val = sum(array,2);
    return val;
}

//sum.c
int sum(int *a, int n) {
    int i, s = 0;
    for (I= 0; i < n; i++) {
        s += a[i];
    }
    return s;
}
```

```
linux> gcc -0g -o prog main.c sum.c
```

1.驱动程序首先运行C预处理器(cpp),它将C的源程序main.c翻译成一个ASCII码的中间文件main.i:

```
cpp [编译参数] main.c main.i
```

2.驱动程序运行C编译器(cc1),它将main.i翻译成一个ASCII汇编语言文件main.s:

```
cc1 main.i -Og [编译参数] -o main.s
```

3.驱动程序运行汇编器(as), 它将main.s翻译成一个可重定位目标文件(relocatable object file)main.o:

```
as [编译参数] -o main.o main.s
```

4.运行链接器程序ld,将main.o和sum.o以及一些必要的系统目标文件组合起来,创建一个可执行目标文件(executable object file)prog:

```
ld -o prog [system object files and args] main.o sum.o
```

运行可执行文件prog

```
linux> ./prog
```

shell调用操作系统中一个叫做加载器(loader)的函数,它将可执行文件prog中的代码和数据复制到内存,然后将控制转移到这个程序的开头

![](./109.png)

### 7.2 静态链接

静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输入,生成一个完全链接的,可以价值和运行的可执行目标文件作为输出.

链接器需完成的任务:

* 符号解析: 目标文件定义和符号引用, 每个符号对应于一个函数,全局变量或者静态变量,**符号解析的目的是将每个符号引用正好和一个符号定义关联起来**
* 重定位: 编译器和汇编器生成从地址0开始的代码和数据节.链接器通过把每个符号定义与一个内存位置关联起来,从而重定位这些节,然后修改所有对这些符号的引用,使得他们指向这个内存位置.

### 7.3 目标文件

**目标文件的三种形式**

* 可重定位目标文件:	包含二进制代码和数据, 其形式可以在编译时与其他可重定位目标文件合并起来,  创建一个可执行目标文件.
* 可执行目标文件:      包含二进制代码和数据, 其形式可以被直接复制到内存并执行
* 共享目标文件:    一种特殊类型的可重定位目标文件, 可以在加载或者运行时被动态地加载进内存并链接.

编译器和汇编器生成可重定位目标文件(包阔共享目标文件). 链接器生成可执行目标文件.

各个系统的目标文件格式:	Windows使用可移植可执行(Portable Executable, PE), MacOS-X使用Mach-O格式.x86-64Linux系统使用可执行链接格式(Executable and Linkable Format, ELF)

### 7.4 可重定位目标文件

![](./110.png)

ELF头以一个16个字节序列开始,描述了该文件的系统的字的大小和字节顺序, 其他包含目标文件类型(可执行,可重定位或共享),机器类型,节头部表的文件偏移,节头部表中条目的大小和数量.不同节的位置和大小是由节头部表描述的

>  .bss 块存储开始(Block Storage Start),指令的首字母缩写.

### 7.5 符号和符号表

每个可重定位目标模块m都有一个符号表, 它包含m定义和引用的符号的信息. 在链接器的上下文中, 有三种不同的符号

* 由模块m定义并能被其他模块引用的全局符号.  全局链接器符号对应于非静态的C函数和全局变量
* 由其他模块定义并被模块m引用的全局符号.这些符号称为外部符号, 对应于在其他模块中定义的费静态C函数和全局变量.
* 纸杯模块m定义和引用的局部符号, 他们对应于带static属性的C函数和全局变量. 这些符号在模块m中任何位置都可就,但是不能被其他模块引用.

**任何带有static属性声明的全局变量或者函数都是模块私有的, 应多使用**

![](./111.png)

### 7.6 符号解析

#### 7.6.1 链接器如何解析多重定义的全局符号

在编译时,编译器向汇编器输出每个全局符号,可能是强(strong)或者弱(weak),而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里.**函数和已初始化的全局变量是强符号,未初始化的全局变量是弱符号**

* 规则1: 不允许有多个同名的强符号
* 规则2: 如果有一个强符号和多个弱符号同名,那么选择强符号
* 规则3: 如果有多个弱符号同名,那么从这些弱符号中任意选择一个

> 当遇到多重定义的全局符号时,可以通过配置选项触发一个错误: GCC-fno-common 或者 -Werror

#### 7.6.2 与静态库链接

**静态库: 将所有相关的目标模块打包成一个单独的文件,	当链接器构造一个输出的可执行文件时, 它只复制静态库里被应用程序引用的目标模块**

在linux中,静态库(.a)以一种称为**存档(archive)**的特殊文件格式存放在磁盘中. 存档文件是一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置

```c
linux> gcc -c addvec.c multvec.c
linux> ar rcs libvector.a addvec.o multvec.o
```

如何让静态库参与编译

```c
linux> gcc -c main2.c
linux> gcc -static-o prog2c -L. -lvector	//-L. 参数告诉链接器在当前目录下查找libvector.a   -lvector是 libvector.a的缩写
```

![](./112.png)

#### 7.6.3 链接器如何使用静态库来解析引用

在符号解析阶段, 链接器从左到右按照他们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件.(驱动程序自动将命令行中所有的.c文件翻译为.o文件),在这次扫描中,链接器维护一个可重定位目标文件的集合E(集合中的文件会被合并起来形成可执行文件), 一个未解析的符号(引用了尚未定义的符号)集合U, 以及在一个前面输入文件中已定义的符号集合D,初始时 EUD均为空

![](./113.png)

![](./114.png)

![](./115.png)

> 假设foo.c 调用 libx.a 和libz.a的函数 , 两个函数库又调用liby.a中的函数

```
linux> gcc foo.c libx.a libz.a liby.a
```

### 7.7 重定位

#### 7.7.2 重定位符号引用(需细看)

todo

### 7.8 可执行目标文件

![](./116.png)

![](./117.png)

对于任何段s,链接器必须选择一个起始地址vaddr,使得

vaddr mod align = off mod align 

### 7.9 加载可执行目标文件

![](./118.png)

![](./119.png)

### 7.10 动态链接共享库

共享库是一个目标模块,在运行或加载是,可以加载到任意的内存地址, 并和一个在内存中的程序链接起来, 这个过程称为动态链接(dynamic linking), 是由一个叫做动态链接器(dynamic linker)的程序来执行的, 共享库也称为共享目标(shared object), linux下以.so表示, windows下以.DLL表示

动态链接器通过执行下面的重定位完成链接任务:

* 重定位libc.so 的文本和数据到某个内存段
* 重定位libvector.so的文本和数据到另一个内存段
* 重定位prog21中所有对libc.so和libvector.so定义的符号的引用.

最后, 动态链接器将控制传递给应用程序, 从这一刻开始, 共享库的位置就固定了,并且在程序执行的过程中都不会改变.

![](./120.png)

### 7.11 从应用程序中加载和链接共享库

linux系统为动态链接器提供了一个简单的接口,允许应用程序在运行时加载和链接共享库

```c
#include <dlfcn.h>
/**
RTLD_GLOBAL	
RTLD_LAZY 立即解析对外部符号的引用	
RTLD_NOW	推迟符号解析知道执行来自库中的代码
*/
void *dlopen(const char *filename, int flag);	//成功则成为执行句柄的指针,失败返回NULL

//指向前茅已经打开了共享库的句柄和一个symbol名字, 如果该符号存在, 就返回符号地址
void *dlsym(void *handle, char *symbol); // 成功则执行符号的指针,出错则为null

int dlclose(void *handle); //成功0 失败-1;

const char *dlerror(void);	//前面调用成功返回NULL, 调用失败返回错误信息
```

### 7.12 位置无关代码

![](./121.png)

### 7.13 库打桩机制

将一个函数进行包装,插入一些桩代码

### 7.14 处理目标文件的工具

![](./122.png)

### 7.15 小结

链接可以在编译时由静态编译器来完成,也可以在加载时和运行时由动态链接器来完成. 链接器处理称为目标文件的二进制文件, 它有三种不同形式:

**可重定位, 可执行和可共享**, 可重定位的目标文件由静态连接器合并成一个可执行目标文件, 它可以加载到内存中并执行    共享目标文件(so共享库)是在运行时由动态链接器链接和加载的或者隐含在调用程序被加载和开始执行时,或者根据需要调用dlopen函数

**链接器** 两个主要任务是符号解析和重定位,  符号解析将目标文件中的每个全局符号绑定到一个唯一定义, 重定位确定每个符号的最终内存地址, 并修改哪些目标引用

**加载器**将可执行文件的内容映射到内存,并运行这个程序

---

## 第八章 异常控制流

![](./123.png)

现代系统通过使控制流发生突变来对这些情况作出反应,一般而言,把这些突变称为**异常控制流(Exceptional Control Flow, ECF)**

### 8.1 异常

在任何情况下, 当处理器检测到有事件发生时,它就会通过一张叫**异常表(exception table)**的跳转表, 进行一个间接过程调用(异常), 到一个专门设计用来处理这类事件的操作系统子程序(**异常处理程序Exception handler**), 异常处理程序处理完后,根据异常类型会发生三种情况中的一种

![](./124.png)

#### 8.1.1 异常处理

![](./125.png)

异常表的起始地址放在**异常表基址寄存器(exection table base register)**的特殊CPU寄存器里

#### 8.1.2 异常类别

![](./126.png)

中断-> 外部IO设备信号

陷阱->系统调用(syscall)

故障->错误引起(缺页异常)

终止->不可恢复致命异常

#### 8.1.3 Linux/x86_64 系统中的异常

![](./127.png)

**段故障(Segmentation fault)**一个程序引用了一个未定义的虚拟内存区域,或者因为程序试图写一个只读的文本段,Linux不会尝试恢复这类故障

![](./128.png)

```c
//hello
int main() {
    write(1, "hello, world\n",13);
    _exit(0);
}
```

![](./129.png)

### 8.2 进程

进程的经典定义就是**一个程序中程序的实例**. 系统中每个程序都运行在某个进程的上下文(context)中. 上下文是由程序正确运行所需状态组成的. 这个状态包括存放在内存中的程序的代码和数据, 栈, 通用目的寄存器内容, 程序计数器, 环境变量,以及打开文件描述符的集合

进程提供给应用程序的关键抽象:

* 一个独立的逻辑控制流, 它提供一个假象, 好像程序独占地使用处理器
* 一个私有的地址空间, 它提供一个假象, 好像程序独占地使用内存系统

PC值的序列叫做**逻辑控制流,也叫逻辑流**

多个流并发地执行的一般现象被称为**并发(concurrency)**, 一个进程和其他进程轮流运行的概念称为多任务(multitasking), 一个进程执行它的控制流的一部分的每一时间段叫做时间片(time slice)

#### 8.2.5上下文切换

内核为每个进程维持一个上下文(context). 上下文就是内核重新启动一个被抢占的进程所需的状态.

### 8.3 系统调用错误处理

使用错误包装函数: 节省代码

![](./130.png)

```c
pid = Fork();
```

### 8.4 进程控制

**获取进程ID**

每个进程都有一个唯一正数(非0)进程ID(PID)

```c
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void);
pid_t getppid(void);
```

**fork()函数**

新创建的子进程几乎但不完全与父进程相同. 子进程得到与父进程用户级虚拟地址空间相同的一份副本, 包括代码,数据段,堆,共享库,以及用户栈.子进程还获得与父进程任何打开文件描述符相同的副本, 当父进程调用fork,子进程可以读写父进程中打开的任何文件, 这时子进程与父进程最大区别是有不同的PID

**fork只被调用一次, 会返回两次:	一次在调用进程(父进程中), 一次死在新创建的子进程中. 在父进程中,fork返回子进程的PID, 在子进程中,fork返回0, 因为子进程的PID总是为非零, 返回值提供一个明确的方法来分辨程序在子进程还是父进程中执行**

### 8.4.3 回收子进程

当一个进程由于某种原因终止时,内核并不是立即把它从系统中清除,相反进程被保持在一种已终止的状态中, 知道被它的父进程回收(reaped). 当父进程回收已终止的子进程时, 内核将子进程的退出状态传递给父进程,然后抛弃已终止的进程,从此时开始,该进程就不存在了. **一个终止了但还未被回收的进程称为僵死进程(zombie)**

**init进程**

如果一个父进程终止了,内核会安排init进程成为孤儿进程的养父. init进程的pid为1, 在系统启动时,由内核创建,不会终止,是所有进程的祖先, 如果父进程没有回收它的僵死紫禁城就终止了,内核会安排init进程去回收它们, 即便僵死进程没有运行,它们任然消耗系统的内存资源.

`waitpid`函数来等待它的子进程终止或者停止

```c
pid_t waitpid(pid_t pid, int *statusp, int options);
```

`sleep`函数让进程挂起一段指定的时间

```c
usigned int sleep(unsigned int secs);
```

`execuv`函数在当前进程的上下文中加载并运行一个新程序

```c
int execve(const char *filename, const char *argv[], const char *envp[]);
```

![](./131.png)

linux提供了几个函数来操作环境数组:

```c
char *getenv(const char *name);

int setenv(const char *name, char *newvalue, int overwrite);

void unsetenv(const char *name);
```

> fork函数在新的紫禁城中运行相同的程序, 新的紫禁城是父进程的一个复制品, execve函数在当前进程的上下文中加载并运行一个新的程序, 它会覆盖当前的进程的地址控件,但并没有创建新的进程. 新的程序仍然有相同的PID, 并且继承了调用execve函数时已打开的所有文件描述符.

### 8.5 信号

![](./132.png)

一个发出而没有被接收的信号叫做**待处理信号(pending signal)**

**转储内存(dumping core)**: 把代码和数据内存段的映像写到磁盘上.

#### 8.5.2 发送信号

```c
pid_t getpgrp(void);	//返回当前进程组ID;

int setpgid(pid_t pid, pid_t pgid);		//改变自己或其他进程的进程组

int kill(pid_t pid, int sig);

unsigned int alarm(unsigned int secs);
```

**3.从键盘发送信号**

```
linux> ls | sort
```

Unix shell使用作业(job)这个抽象概念来表示为对一条命令求值而创建的进程.

#### 8.5.3 接收信号

当内核把进程p从内核模式切换到用户模式时,会检查p进程的未被阻塞的待处理信号集合(pending &~blocked).如果这个集合为空,内核将控制传递到p的逻辑控制流中的下一条指令. 如果集合非空, 内核会选择集合中的某个信号k,并且强制p接收信号k.收到这个信号会出发进程才去某种行为,一旦进程完成了这个行为, 控制就传递回p的逻辑流中的下一条指令.每个信号类型都有预定义默认行为, 下面的一种:

* 进程终止
* 进程终止并转储内存
* 进程停止(挂起)直到被SIGCONT信号重启
* 进程忽略该信号

进程可以通过使用signal函数修改和信号相关的默认行为, 但是SIGSTOP和SIGKILL它们的默认行为是不能修改的.

```c
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

---

## 第9章 虚拟内存

虚拟内存(VM)提供了三个重要能力:

1. 它将主存看成是一个存储在磁盘上的地址空间的告诉缓存, 在主存中只保留活动区域, 并根据需要在磁盘和主存之间来回传送数据, 通过这种方式高效地使用主存
2. 它为每个进程提供了一直的地址空间,从而简化了内存管理
3. 它保护了每个进程的地址空间不被其他进程破坏

### 9.1 物理和虚拟寻址

![](./133.png)

### 9.3虚拟内存作为缓冲的工具

在任意时刻,虚拟页面的集合都分为三个不相交的子集:

* 未分配: VM系统还未分配(或创建)的页
* 缓存的: 当前已缓存在物理内存中的已分配页
* 未缓存的: 未缓冲在物理内存中的已分配页

![](./134.png)

磁盘和内存之间的传送也的活动叫做**交换(swapping)**或者**页面调度(paging)**

如果工作集的大小超出了物理内存的大小,那么程序将产生一种不幸的状态, 叫做**抖动(thrashing)**, 这时也没将不断换进换出.

### 9.4 虚拟内存作为内存的管理工具

将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法作为**内存映射(memory mapping)**

### 9.5 虚拟内存作为内存保护的工具

![](./135.png)

当一条指令违反了上述的许可条件, CPU就触发一个一般保护故障, 将控制传递给一个内核中的异常处理程序, Linux shell 一般将这种异常报告为"段错误(segmentation fault)"

### 9.6 地址翻译

### 9.7 案例研究 Intel Core i7/Linux内存系统

#### 9.7.2 Linux虚拟内存系统

![](./136.png)

内核虚拟内存包含内核中的代码和数据结构. 内核虚拟内存某些区域被映射到所有进程共享的物理页面, 例如每个进程共享内核的代码和全局数据结构.

**1.Linux虚拟内存区域**

Linux将虚拟内存组织成一些区域(也叫做段)的集合. 一个区域(area)就是已经存在着的(已分配的)虚拟内存的连续片(chunk).

![](./137.png)

vm_area_structs: 描述了当前虚拟地址空间的一个区域, 比如代码,数据区域

**2.Linux缺页异常处理**

当触发一个缺页, 异常导致控制转移到内核的缺页处理程序, 处理程序随后会执行如下步骤: 虚拟地址是否合法,(缺页处理程序搜索区域结构的链表,把A和每个区域结构中的vm_start和vm_end做比较,如果不合法会触发一个段错误, **从头到尾查是很耗时的,所以Linux使用某些未显示的自动,在链表中构建一棵树,在这课树上查找**)

![](./138.png)

### 9.8 内存映射

虚拟内存区域可以映射到两种类型:

* Linux文件系统中的普通文件
* 匿名文件

如果进程将一个共享对象映射到它的虚拟地址控件的一个区域内,那么这个进程对这个区域的写操作, 对于那些也罢这个共享对象映射到它们虚拟内存的其他进程而言也是可见的, 这些变化会反映在原始对象中

一个映射共享对象的虚拟内存区域叫做**共享区域**

![](./139.png)

#### 9.8.2 fork函数

#### 9.8.4 使用mmap函数的用户级内存映射

```c
#include <unistd.h>
#include <sys/mman.h>
void *mmap(void *start, size_t length, int port, int flags, int fd, off_t offset);

//取消映射
int munmap(void *start, size_t length);
```

### 9.9 动态内存分配

![](./140.png)

对于每个堆顶,内核维护着一个变量brk(break),它指向堆的顶部

**分配器**将堆视为一组不同大小的块(block)的集合来维护. 分配器类型:

* 显示分配器(explicit allocator),要求显示的释放

  ```c
  malloc/free   new/delete
  ```

* 隐式分配器(implicit allocator): 自己检测一个已分配块何时不再被程序使用, 就释放这个块, 也叫做垃圾收集器

#### 9.9.1 malloc 和 free 函数

```c
void *malloc(size_t size);
```

返回一个指针,指向大小为至少size字节的内存块.  可能包含数据对齐,32位模式中地址是8的倍数,64位中地址是16的倍数

calloc是基于malloc的瘦包装函数, 将分配的内存初始化为零.要改变分配块的大小可以用realloc函数

```c
#include <unistd.h>
void *sbrk(intptr_t incr);
```

sbrk函数通过讲内核的brk指针增加incr来扩展和收缩堆.

#### 9.9.6 隐式空闲链表

![](./141.png)

标记一个堆块是否使用的简单格式,

![](./142.png)

- 优点: 操作简单
- 缺点: 任何操作的开销,都需要对空闲链表进行搜索.

内存块合并分类:

* 立即合并:在每次一个块被释放时, 就合并所有相邻的块
* 推迟合并:在某个稍晚的时候合并,例如推迟合并直到某个分配请求失败.

![](./143.png)

**边界标记:** 在每个块的结尾处添加一个脚部, 脚部就是头部的一个副本.每个块包括这样一个脚部,分配器可以通过检查它的脚部, 判断前茅一个块的起始位置和状态.

#### 9.9.13 显式空闲链表

![](./145.png)

显式空闲链表的缺陷是空闲块必须足够大,以包含所有需要的指针,以及头部和可能的脚部, 这导致了更大的最小块大小, 潜在提高了内存碎片

#### 9.9.14 分离的空闲链表

### 9.11 C程序中常见的与内存有关的错误

**1.间接引用坏指针**

```c
scanf("%d", &val);

scanf("%d", val);	//错误
```

**2.允许栈缓冲区溢出**

```c
void bufoverflow() {
    char buf[64];
    gets(buf);	//可能造成栈缓冲区溢出   应使用 fgets
}
```

**3.引用指针而不是引用指针指向的对象**

```c
int *size;

*size--;	//错误
(*size)--;	//正确
```

**4.误解指针运算**

```c
int *search(int *p, int val) {
    while(*p && *p != val)
        p += sizeof(int);	//错误,应该用p++;
    return p;
}
```

**5.引用不存在的变量**

```c
int *stackref() {
    int val;
    return &val;
}
```

---

## 第十章 系统级I/O

### 10.1 Unix I/O

一个Linux文件就是一个m个字节的序列:

​	B<sub>0</sub>,B<sub>1</sub>,B<sub>2</sub>,B<sub>3</sub>,...,B<sub>m-1</sub>, 	所有的I/O设备(网络,磁盘,终端)都没模型化为文件,而所有的输入和输出都被当做对相应文件的读和写来执行.

* 打开文件: 内核返回一个小的非负数,叫做**描述符**,内核记录有关文件的信息,应用只需知道描述符
* Linux Shell每个进程开始时都有三个打开的文件: 标准输入(0),标准输出(1),标准错误(2)
* 改变文件位置: seek
* 读写文件: 读操作会触发end-of-file(EOF)
* 关闭文件: 通知内核关闭文件, 内核会释放文件打开时的数据结构.并将描述符恢复到可用的描述符池

### 10.2 文件

Linux文件类型:

* 普通文件(regular file) 和 二进制文件(binary file), 对内核来说两种文件没有区别
* 目录(directory): 包含一组链接(link)的文件, 每个链接都将一个文件名映射到一个文件, 这个文件可能是一个另一个目录,**每个目录至少会有两个条目: **"."**是到该目录自身的链接, **".."**是到父目录的链接**
* 套接字(socket) 用来与另一个进程跨网络通信的文件

### 10.3 打开和关闭文件

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(char *filename, int flags, mode_t mode);

int close(int fd);
```

成功返回文件描述符,失败返回-1

flags:

* O_RDONLY
* O_WRONLY
* O_RDWR
* O_CREAT
* O_TRUNC
* O_APPEND

mode: 指定新文件的访问权限位

![](./146.png)

### 10.4 读和写文件

![](./147.png)

size_t和ssize_t区别?

**在x86_64系统中, size_t 被定义为unsigned long, ssize_t(有符号大小)被定义为long, 因为文件出错时返回-1**

### 10.5 RIO包健壮地读写

RIO(Robust I/O) `#include "csapp.h"`

### 10.6 读取文件元数据

应用程序能够调用`stat`和`fstat`函数,检索到关于文件的信息(元数据metadata)

```
#include <unistd.h>
#include <sys/stat.h>

int stat(const char *filename, struct stat *bif);
int fstat(int fd, struct stat *buf);
```

![](./148.png)

### 10.7 读取目录内容

![](./149.png)

d_name: 文件名 d_ino: 文件位置

```c
int closedir(DIR *dirp);
```

### 10.8 共享文件

内核用三个相关的数据结构表示打开的文件:

* 描述符表(descriptor table): 每个进程都有独立的描述符表,表项是由进程打开的文件描述符来索引的.
* 文件表: 所有进程共享这张表,表项组成(当前文件位置,引用计数,指向v-node表对应表项指针), 关闭描述符会减少相应的文件表项中的引用计数, 内核不会删除这个文件表现,除非引用计数为0
* v-node 表.所有进程共享,表项包含stat结构中大多数信息.

![](./150.png)

![](./151.png)

![](./152.png)

### 10.9 I/O重定向

Linux shell 提供了I/O重定向操作符,允许用户将磁盘文件和标准输入输出联系起来, IO重定向的实现类似于`dup2`函数

```
linux>  ls > foo.txt
```

```c
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

![](./153.png)

### 10.10 标准IO

C语言定义了一组高级输入输出函数,称为**标准IO库**, 这个库提供了

* 打开和关闭文件函数(fopen和fclose)
* 读和写字节函数(fread和fwrite)
* 读和写字符串函数(fgets和fputs)
* 复杂的格式化IO函数(scanf和printf)

```c
#include <stdio.h>
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
```

类型FILE的流式对文件描述符和流缓冲区的抽象, 使用流缓冲区的目的为了使开销较高的LinuxIO系统调用的数量尽可能小

### 10.11 综合: 应该使用哪些IO函数?

![](./154.png)

**指导规则:**

* 只要有可能就使用标准IO
* 不要使用scanf或者rid_readlinb来读二进制文件
* 对网络套接字的IO使用RIO函数

标准IO流式全双工的, 对流和对套接字的限制, 有时候会互相冲突

* 限制一: 跟在输出函数之后的输入函数, 一个输入不能跟随在一个输出函数之后,需要fflush清空与流相关的缓冲区
* 限制二: 跟在输入函数之后的输出函数, 如果中间没有插入对fseek,fsetpos,rewind调用,不能一个输入后面跟一个输出函数,除非遇到了文件结束

这种限制给对套接字流带来的问题, 因为套接字使用lseek函数是非法的.

解决方案: 限制一可以通过在每个输入操作前刷新缓冲区这样的规则来满足,  限制二的方法是对打开的套接字描述符打开两个流,一个读一个写

```c
FILE *fpin, *fpout;
fpin = fdopen(sockfd, "r");
fpout = fdopen(sockfd, "w");
```

---

## 第11章 网络编程

Internet和internet: 小写描述一般概念, 大写描述一种具体实现.

* LAN(Local Area Network)局域网
* 以太网段(Ethernet segment)

* WAN(Wide-Area Network)广域网

![](./155.png)

### 11.3 全球IP因特网

![](./156.png)

**TCP/IP(Transmission Control Protocol/Internet Protocol, 传输控制协议/互联网络协议)** : IP协议提供基本的命名方法和递送机制, 这种机制能够从一台因特网主机往其他主机发送**包(数据报datagram)**, IP机制从某种意义上而言是不可靠的, 因为, 如果数据报在网络中丢失或者重复, 它并不会试图恢复.

**UDP(Unreliable Datagram Protocol, 不可靠数据报协议)**稍微扩展了IP协议,这样包可以在进程间而不是主机间传送.

TCP是一个构建在IP之上的复杂协议, 提供了进程间可靠的全双工连接.

小端法: 主机字节序(host byte order)

大端法: 网络字节序(network byte order)

#### 11.3.1 IP地址

```c
#include <arpa/inet.h>
uint32_t htonl(uint32_t hostlong);	//32位主机字节序->网络字节序
uint16_t htons(uint16_t hostlong);

uint32_t ntohl(uint32_t hostlong);	//32为网络字节序->主机字节序
uint16_t ntohs(uint16_t hostlong);
```

IP地址通常是以一种称为**点分十进制表示法**来表示的,它的每个字节由十进制表示,并用句点和其他字节间分开. 例如 128.2.192.242 -> 0x8002c2f2

`inet_pton`和`inet_ntop`函数来实现IP地址和点分十进制之间的转换

![](./157.png)

"n"代表网络,"p"代表表示

**因特网定义了域名集合和IP地址集合之间的映射. 直到1988年, 这个映射都是通过一个叫做HOSTS.TXT的文本文件夹来手工维护, 从那之后, 这个映射是通过分布世界范围内的数据库(DNS(Domain Name System, 域名系统))来维护,DNS数据库由上百万的主机条目结构(host enry structure)组成.**

**每台因特网主机都有本地的域名localhost, 这个域名总是映射为回送地址(loopback addres)127.0.0.1**

多个域名可以映射到同一个IP地址 或者 一个域名可以映射到多个IP地址,   一个套接字是连接的一个端点. 每个套接字都有相应的套接字地址. 是由一个因特网地址和一个16位的整数端口组成.用"地址:端口"来表示

当客户端发起一个连接请求时,客户端套接字地址中的端口是由内核自动分配的, 称为**临时端口(ephemeral port)**, 服务器套接字地址中的端口通常是某个知名端口和这个服务相对应,例如Web服务器端口80, 电子邮件服务器端口25 每个知名端口的服务都有一个对应的知名的服务名, Web-http email-smtp, 文件**/etc/services**包含一张这个机器提供的知名名字和知名端口间的映射

![](./158.png)

### 11.4 套接字接口

![](./159.png)

**EOF:**	EOF不是一个字符, EOF是由内核检测到的一种条件. 应用程序在它接收到一个有read函数返回的零返回码时, 他就会发现EOF条件,对于磁盘文件,当前文件位置超出文件长度时,会发生EOF, 对于因特网连接, 当一个进程关闭连接它的那一端,会发生EOF, 连接另一端的进程在试图读取流中最后一个字节之后的字节时,会检测到EOF

### 11.5 Web服务器

#### 11.5.2 Web内容

对于web客户端和服务器而言, 内容是与一个**MIME(Multipurpose Internet Mail Extensions, 多用途的网际邮件扩充协议)**类型相关的字节序列.

![](./160.png)

Web服务器以两种不同的方式向客户端提供内容:

* 取磁盘文件, 磁盘文件称为静态内容(static content), 返回给客户端的过程称为服务静态内容(serving static content)
* 运行一个可执行文件,并将输出返回给客户端,称为动态内容, 服务动态内容

确定一个请求是静态内容还是动态内容:

* 确定一个URL指向的内容是静态还是动态内容没有标准规则, 但是服务器有通用 管理规则, 经典方法是确定一组目录,例如cgi-bin,可执行的都放在该目录
* 后缀中的"/"表示请求类型的主目录 usr/httpd/html   usr/httpd/cgi-bin
* 最小的URL后缀是"/"字符, 所有服务器将其扩展为某个默认的主页,例如/index.html,浏览器在URL后添加缺失的"/",服务器又把"/"扩展到某个默认的文件名

#### 11.5.3 HTTP事务

**1. HTTP请求**

**2. HTTP相应**

#### 11.5.4 服务动态内容

**CGI(Common Gateway Interface, 通用网关接口)**

**1.客户端如何将程序参数传递给服务器**

?: 分隔文件名和参数

&: 分隔参数

%20 空格

**2.服务器如何将参数传递给子进程**

```js
GET /cgi-bin/adder?15000&213 HTTP/1.1
```



fork创建子进程, 并调用execve在子进程上下文中执行/cgi-bin/adder,调用execve之前子进程将CGI环境变量QUERY_STRING设置为"15000&213",运行时可以通过LInux getenv获取

**3.服务器如何将其他信息传递给子进程**

**4.子进程将它的输出发送到哪里**

一个CGI程序将它的动态内容发送到标准输出, 在子进程加载并运行CGI程序之前, 它使用Linux dup2函数将标准输出重定向到客户端相关联的已连接描述符, 因此任何CGI程序写到标准输出的东西都会直接到达客户端

---

## 第12章 并发编程

如果逻辑控制流在时间上重叠, 那么他们就是并发的(concurrent)

应用级并发使用场景:

* 访问慢速IO设备
* 与人交互
* 推迟工作以降低延迟
* 服务多个网络客户端
* 多核机器上并行计算

**并发程序**构造方法

* 进程. 由内核调度和维护,进程拥有独立的虚拟地址空间,想要和其他流通信, 需要显式的进程间通信(interprocess communication,IPC)机制
* IO多路复用
* 线程

### 12.1 基于进程的并发编程

![](./161.png)

![](./162.png)

#### 12.1.2进程优劣

优:	进程共享文件表,不共享用户地址空间, 不用担心另一个进程会覆盖虚拟内存

缺:	独立地址空间使得进程共享状态信息更加困难, 为了共享信息,必须显式的IPC机制

### 12.2 基于IO多路复用的并发编程

