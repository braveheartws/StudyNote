# 深入理解Java虚拟机第三版

## 第二章 Java内存区域与内存溢出异常

![](./imgs/01.png)

### 2.2.1 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

### 2.2.2 Java虚拟机栈

* 线程私有
* 生命周期与线程相同

描述的线程内存模型:	每个方法被执行的时候都会同步创建一个栈针, 用于存储局部变量表, 操作数栈, 动态链接, 方法出口等.

虚拟机栈内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩 展时无法申请到足够的内存会抛出OutOfMemoryError异常。 (HotSpot虚拟机栈容量是不可以动态扩展的)

### 2.2.3 本地方发栈

用于执行Native方法,提供各种服务

### 2.2.4 堆

* 线程共享
* 虚拟机启动时创建

并非所有的实例都会在堆内存分配. 随着逃逸分析技术会让对象直接在栈上分配, 栈上分配的性能远大于堆上分配

### 2.2.5 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

**永久代?**

>说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设 计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则 上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头 来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到 内存溢出的问题.
>
>考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta- space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。 

相对而言，垃圾收集行为在这个区域的 确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻.

### 2.2.6 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 

### 2.2.7 直接内存

它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据.	这说明这块区域虽然不受Java堆大小限制,但是会受到本机总内存限制

## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

step1.当虚拟机遇到一条new指令时,首先会去根据指令参数看能否在常量池找到一个类的符号引用, 并检查这个符号代表的类是否被加载, 解析, 初始化过.如果没有则需要先执行相应的类加载过程.

step2.内存分配完后,会将分配到的内存空间全部初始化为0(不包括对象头)

step3.Java虚拟机对对象进行必要设置: 如何找到类的元数据信息,	对象的hash码,	偏向锁?, GC分代年龄, 这些信息会保存在对象头之中.

step4.到这里前三步对于虚拟机来说对象已经被创建好了,	但从Java程序视角来看并未完成,	这时<init>方法还未执行, Java编译器会对new生成两条指令: new和invokespecial, new完成前三步, invokespecial会调用对象的构造方法. 这时才算真正将对象创建出来.

**指针碰撞**	假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一 边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离

**空闲列表**	但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录



由于对象的分配是很频繁的行为,	这种指针碰撞对象会引发线程安全问题, 那么如何解决这些问题呢?

- 一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败 重试的方式保证更新操作的原子性
- 把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。

### 2.3.2 对象的内存布局

在HotSpot虚拟机里,对象在堆内存中的布局可以分为三部分:

- 对象头
  - 运行时数据
    - Hash码(25)
    - GC分代年龄(4),所以最大年龄是15
    - 锁状态标志,线程持有的锁,偏向线程ID,偏向时间戳
    - 如果是数组还存在数组长度的一块区域
  - 类型指针: 对象指向它的类型的元数据指针,用来确定对象是属于哪个类的实例.
- 实例数据
- 对齐填充:  非必然存在, 只起占位符的作用. 虚拟机内存管理系统要求对象是8字节的整数倍.

### 2.3.3 对象的访问定位

使用句柄池和直接指针访问

![](./imgs/02.png)

![](./imgs/03.png)

用句柄来访问的最大好处就是reference中存储的是稳定句柄地 址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference本身不需要被修改

使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，(HotSpot采用直接指针)

## 2.4 内存溢出

### 2.4.2 虚拟机栈和本地方法栈溢出

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
- 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。

**Windows平台的虚拟机中，Java的线程是映射到操作系统的内核线程上**



Q: 如果我们遇到创建多线程导致的OOM,在不能减少线程数的情况下如何换取更多的线程数?

A: 减少最大堆和减少栈容量



String.intern()

>String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的 字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加 到常量池中，并且返回此String对象的引用。

从JDK1.7开始字符串常量池被移动到Java堆中;所以在如下的代码中几乎不会抛出OOM

```java
Set<String> set = new HashSet<>(1000000);
int i = 0;
while (true) {
    set.add(String.valueOf(i++).intern());
}
```

---

## 第3章 垃圾收集器与内存分配策略

## 3.2 如何判断对象已死?

### 3.2.1 引用计数算法

在对象中添加一个引用计数器，每当有一个地方 引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可 能再被使用的。

优点:

- 原理简单	判定效率高

缺点:

- 需要占用额外的空间进行引用计数
- 很难解决对象的相互循环引用问题

### 3.2.2 可达性分析算法 

通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。 

GC Roots 有哪些?

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。 
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 3.2.3 引用

* 强引用		Object o = new Object();  只要强引用关系存在, 虚拟机宁愿抛出OOM也不会回收
* 软引用        是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。
* 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。
* 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

### 3.2.4 是否回收?

要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没 有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是 否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。 		也就是说第一次被标记, 第二次筛选后就会回收; 任何一个对象的finalize()方法都只会被执行一次

### 3.2.5 回收方法区

方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。

回收不再使用的类型需同时具备一下三个条件:

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。 
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 3.3 垃圾回收算法

垃圾收集类型

- 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。 

- 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。 

- 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。 ·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

### 3.3.2 标记-清除算法 

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回 收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回 收所有未被标记的对象。很多的垃圾回收算法都是以该算法为基础的。

缺点:

- 执行效率不稳定——标记和清除的执行效率会随着对象数的增加而降低
- 内存空间碎片化问题——标记清除后会产生大量内存碎片；会导致大对象在分配空间时无法找到合适位置而再次触发GC

### 3.3.3 标记-复制算法

将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

优点：

- 没有内存碎片，分配效率高

缺点：

- 浪费了一半内存空间

HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新 生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会 被“浪费”的。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）。 

### 3.3.4 标记-整理算法 

标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果 不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存 活的极端情况，所以在老年代一般不能直接选用这种算法。 

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可 回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存

移动则内存回收时会更复杂，不移动则内存分配时会更复杂。

## 3.4 HotSpot的算法细节实现

## 3.5 经典垃圾收集器 

### 3.5.1 Serial收集器

![](./imgs/05.png)

* 简单而高效（与其他收集器的单线程相比）
* 单核或者核心数较少时, 没有线程交互的开销
* 额外内存消耗最小

### 3.5.2 ParNew收集器 

![](./imgs/06.png)

ParNew收集器实质上是Serial收集器的多线程并行版本	ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果

### 3.5.3 Parallel Scavenge收集器 

特点:

1. 标记-复制

2. 关注吞吐量

吞吐量= 运行用户代码时间/运行用户代码时间 + 垃圾收集的时间；例如：99/99 + 1 = 99%

### 3.5.4 Serial Old收集器

特点：

1. 标记-整理

### 3.5.5 Parallel Old收集器

特点：

1. 标记-整理
2. 支持多线程并发收集

### 3.5.6 CMS收集器

特点：

1. 标记-清除
2. 以获取最短回收停顿时间为目标的收集器。
3. 并发收集、低停顿

缺点：

1. 会占用一部分线程资源，使程序变慢。核心数大于4垃圾收集的线程资源占用百分比会减小（CMS默认启动的回收线程数是（处理器核心数量 +3）/4
2. 浮动垃圾：并发清理阶段用户线程会不断产生新垃圾，而这部分是无法在这一次垃圾回收里面清理掉
3. 因为是标记清除，所以会产生空间碎片。会在FullGC前会进行碎片整理

垃圾收集四个步骤：

1）初始标记（CMS initial mark） 初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快

2）并发标记（CMS concurrent mark） 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行

3）重新标记（CMS remark） 而重 新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短

4）并发清除（CMS concurrent sweep）清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。 

![](./imgs/07.png)



增量式并发收集器（了解即可）

> 并发标记、清理的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变 慢的时间更多了，但速度下降幅度就没有那么明显。

### 3.5.7 Garbage First（G1）收集器 

G1与CMS比较：

**优势：**

* 可以指定最大停顿时间
* 分Region的内存布局
* 按收益动态确定回收集

G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法



**劣势：**

- 在用户程序运行过程 中，G1无论是为了垃圾收集产生的内存占用Footprint）还是程序运行时的额外执行负载 （Overload）都要比CMS要高。 
- G1用的卡表处理跨代指针，但是比CMS更加复杂，内存占用会更多
- G1收集器要比其他的传统垃 圾收集器有着更高的内存占用负担。根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额 外内存来维持收集器工作。 

总结：以上的优缺点对比仅仅是针对G1和CMS两款垃圾收集器单独某方面的实现细节的定性分析，通常 我们说哪款收集器要更好、要好上多少，往往是针对具体场景才能做的定量比较。按照笔者的实践经 验，目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其 优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间，当然，以上这些也仅是经验之谈，不 同应用需要量体裁衣地实际测试才能得出最合适的结论，随着HotSpot的开发者对G1的不断优化，也 会让对比结果继续向G1倾斜。 



## 3.6 低延迟垃圾收集器

衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟 （Latency），三者共同构成了一个“不可能三角[1]”。

![](./imgs/08.png)

*浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的。

### 3.6.1 Shenandoah收集器 

OpenJDK 12才有 而OracleJDK 一直在排挤

### 3.6.2 ZGC收集器

* 低延迟

![](./imgs/09.png)



![](./imgs/10.png)

---

## 第4章 虚拟机性能监控、故障处理工具

### 4.2.7 基础工具总结

![](./imgs/11.png)

## 第6章 类文件结构 

“计算机只认识0和1，所以我们写的程序需要被编译 器翻译成由0和1构成的二进制格式才能被计算机执行。”十多年过去了，今天的计算机仍然只能识别0 和1，但由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展， 把我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语 言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。

![](./imgs/13.png)

## 6.3 Class类文件的结构

任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。

Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。 

根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数 据，这种伪结构中只有两种数据类型：“无符号数”和“表”。

- 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串 值。
- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名 都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视 作是一张表，这张表由表6-1所示的数据项按严格顺序排列构成。 

![](./imgs/14.png)

### 6.3.1 魔数与Class文件的版本

魔数：唯一作用是确定这个文件是否为 一个能被虚拟机接受的Class文件。不仅是Class文件，很多文件格式标准中都有使用魔数来进行身份识 别的习惯，譬如图片格式，如GIF或者JPEG等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。

次版本号，主版本号：告诉虚拟机当前的可以被JDK几版本以上的虚拟机执行。

### 6.3.2 常量池 

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常 量池容量计数值（constant_pool_count）。与Java中语言习惯不同，这个容量计数是从1而不是0开始的，如图6-3所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就 代表常量池中有21项常量，索引值范围为1～21。在Class文件格式规范制定之时，设计者将第0项常量 空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下 需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。Class文件结构中只有 常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的 容量计数都与一般习惯相同，是从0开始。

![](./imgs/15.png)

常量池中主要存放两大类常量：

- 字面量（Literal）
  - 文本字符串
  - 被声明为final的常量值

- 符号引用（Symbolic References）。

  - 被模块导出或者开放的包（Package） 
  - 类和接口的全限定名（Fully Qualified Name） 

  - 字段的名称和描述符（Descriptor） 

  - 方法的名称和描述符 

  - 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic） 

  - 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

  

  ![](./imgs/16.png)![]

![](./imgs/18.png)

通过javap反编译得到如下结构：

![](./imgs/17.png)

方法签名标识符：

![](./imgs/19.png)

### 6.3.6 通过简单例子分析class文件结构

![](./imgs/21.png)

```java
package com.havefun.javaapitest;

public class TestClass {
    private int m;

    public TestClass() {
    }

    public int inc() {
        return this.m + 1;
    }
}

字节码数据的表示：
-----------魔数与版本----------
CA FE BA BE：魔数
00 00 00 34：次版本与主版本
00 16      ：常量池数量 -> 0x16转换成10进制 = 22
------------常量池-------------
0A 00 04 00 12：(索引1)（这里的引用指向索引都是从）#4 #18
    0A 查表表示是method引用； 
    00 04：声明方法的类描述符在常量的索引   ->   java/lang/Object
    00 12：0x12 转10进制 = 18 名称及类型描述符的索引 -> "<init>":()V
09 00 03 00 13：(索引2) #3 #19 // com/havefun/javaapitest/TestClass 
    09：字段符号引用
    03：指向字段类接口信息的ClassInfo索引 -> m
    00 13：16进制转10 -> 19 名字和类型索引：->I
07 00 14：(索引3)                             -> // com/havefun/javaapitest/TestClass
    07：class info
    00 14： 全限定名常量项索引 0x14-> 20
07 00 15：(索引4)                             -> // java/lang/Object
    07：class info
    00 15： 全限定名常量项索引 0x15-> 21 
01 00 01 6D：(索引5)
    01：Utf8信息
    00 01：长度为1
    6D：转10进制=109 ASICC = m
01 00 01 49：(索引6)
    I
01 00 06 3C 69 6E 69 74 3E：(索引7)
    <init>
01 00 03 28 29 56：(索引8)
    ()V
01 00 04 43 6F 64 65：(索引9)
    Code
01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65：(索引10)
    LineNumberTable
01 00 12 4C 6F 63 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65：(索引11)
    LocalVariableTable
01 00 04 74 68 69 73：(索引12)
    this
01 00 23 4C 63 6F 6D 2F 68 61 76 65 66 75 6E 2F 6A 61 76 
    61 61 70 69 74 65 73 74 2F 54 65 73 71 43 6C 61 73 73 3B：(索引13)
    01： utf8 信息 23：字符长度
    Lcom/havefun/javaapitest/TestClass;
01 00 03 69 6E 63：(索引14)
    inc
01 00 03 28 29 49：(索引15)
    ()I
01 00 0A 53 6F 75 72 63 65 46 69 6C 65：(索引16)
    01：utf信息 0A：长度
    SourceFile
01 00 0E 54 65 73 74 43 6C 61 73 73 2E 6A 61 76 61：(索引17)
    TestClass.java
0C 00 07 00 08：(索引18) #7 #8
    0C: 字段或方法的部分符号引用
    07：字段或方法名称常量索引  -> <init>
    08：字段或方法描述符常量索引 -> ()V
0C 00 05 00 06：(索引19)    #5  #6
    0C：字段或方法的部分符号引用
    05：字段或方法名称常量索引  -> m
    06：字段或方法描述符常量索引 -> I
01 00 21 63 6F 6D 2F 68 61 76 65 66 75 6E 2F 6A 61 76 61 61 70 69
    74 65 73 74 2F 54 65 73 74 43 6C 61 73 73：(索引20)
    com/havefun/javaapitest/TestClass
01 00 10 6A 61 76 61 2F 6C 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74：(索引21)
    java/lang/Object

--------------------常量池结束----------------------------
00 21：访问标记 -> 0x0020 | 0x0001 -> ACC_PUBLIC | ACC_SUPER

00 03：当前类的信息 03 常量池索引 对应 com/havefun/javaapitest/TestClass
00 04：父类信息     04 常量池索引 对应 java/lang/Object
00 00： 没有接口
00 01：  一个字段
----------------字段信息数组---------
00 02：ACC_PRIVATE
00 05：字段名索引5 -> m
00 06：描述符-> I 表示int类型
00 00
----------------方法信息----------
00 02：方法数量

00 01：ACC_PUBLIC
00 07：名称->从常量池查得到 <init>
00 08：方法签名描述符 ->  从常量池查得到  ()V
00 01： 方法属性数量 1
    00 09： attribute_name_index -> Code
    00 00 00 2F：    attribute_length-> 47
    00 01：  max_stack 操作数栈最大深度
    00 01：  局部变量所需空间 max_locals 单位是Slot，不超过32位的 每个局部变量占用一个slot
    00 00 00 05： code_length
        这里是4个字节理论上最大可以是2的32次幂，但是虚拟机规范限定了一个方法不允许超过65535条字节指令
    
    2A B7 00 01 B1：
        2A aload_0：第0个变量槽中为reference类 型的本地变量推送到操作数栈顶。
        B7 invokespecial：是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方    法或者它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodre    f_info类型常量，即此方法的符号引用(01) -> #1 = Methodref  #4.#18  // java/lang/Object."<init>":()V
        
        B1 得0xB1对应的指令为return，含义是从方法的返回，并且返回值为void。这条指 令执行后，当前方法正常结束
    
    00 00：扩展表长度
    00 02：属性长度 2
        00 0A： -> LineNumberTable
        00 00 00 06：
        00 01：
            00 00：
            00 03：line_number:3
```

通过`javap -v`生成的反编译文件

```java
Classfile /C:/code/java-workspace/JavaAPITest/out/production/JavaAPITest/com/havefun/javaapitest/TestClass.class
  Last modified 2022-4-19; size 401 bytes
  MD5 checksum 7b310a43cc25a1de2d60bf2513c28ed4
  Compiled from "TestClass.java"
public class com.havefun.javaapitest.TestClass
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#18         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#19         // com/havefun/javaapitest/TestClass.m:I
   #3 = Class              #20            // com/havefun/javaapitest/TestClass
   #4 = Class              #21            // java/lang/Object
   #5 = Utf8               m
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/havefun/javaapitest/TestClass;
  #14 = Utf8               inc
  #15 = Utf8               ()I
  #16 = Utf8               SourceFile
  #17 = Utf8               TestClass.java
  #18 = NameAndType        #7:#8          // "<init>":()V
  #19 = NameAndType        #5:#6          // m:I
  #20 = Utf8               com/havefun/javaapitest/TestClass
  #21 = Utf8               java/lang/Object
{
  public com.havefun.javaapitest.TestClass();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/havefun/javaapitest/TestClass;

  public int inc();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field m:I
         4: iconst_1
         5: iadd
         6: ireturn
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       7     0  this   Lcom/havefun/javaapitest/TestClass;
}
SourceFile: "TestClass.java"
```

问：为什么构造方法和inc方法都是空参，而args_size却又=1？

答：Java语言里面的潜规则：在任何实例方法里面，都可以通过“this”关键字访问到此方 法所属的对象。这个规则只对实例方法有效，如果方法是static，那么argsize就会等于0。

### 6.3.7 try-catch执行流程

![](./imgs/20.png)

- 如果try语句块中出现属于Exception或其子类的异常，转到catch语句块处理；
- 如果try语句块中出现不属于Exception或其子类的异常，转到finally语句块处理；
- 如果catch语句块中出现任何异常，转到finally语句块处理。
- 如果finally有return一定会返回finally的值 

## 6.4 字节码指令简介

由于限制了Java虚 拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条

比如在分析字节码的时候得到2A B7 00 01 B1; 2A=iload_0; B7= invokespecial B1= return

Java虚拟机基础执行模型：

```java
do {
    自动计算PC寄存器的值加1; 
    根据PC寄存器指示的位置，从字节码流中取出操作码; 
    if (字节码存在操作数) 从字节码流中取出操作数; 
    执行操作码所定义的操作; 
} while (字节码流长度 > 0);
```

### 6.4.2 加载和存储指令

- 将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n> 

- 将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、 fstore_<n>、dstore、dstore_<n>、astore、astore_<n> 

- 将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d> 

- 扩充局部变量表的访问索引的指令：wide 

### 6.4.3 运算指令

- 加法指令：iadd、ladd、fadd、dadd 

- 减法指令：isub、lsub、fsub、dsub 

- 乘法指令：imul、lmul、fmul、dmul 

- 除法指令：idiv、ldiv、fdiv、ddiv

### 6.4.5 对象创建与访问指令

- 创建类实例的指令：new 

- 创建数组的指令：newarray、anewarray、multianewarray 

- 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 

  daload、aaload 

### 6.4.6 操作数栈管理指令

* 将操作数栈的栈顶一个或两个元素出栈：pop、pop2

* 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、 

  dup2_x1、dup_x2、dup2_x2

### 6.4.7 控制转移指令

- 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、
- 复合条件分支：tableswitch、lookupswitch 
- 无条件分支：goto、goto_w、jsr、jsr_w、ret

### 6.4.8 方法调用和返回指令 

- invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）， 

  这也是Java语言中最常见的方法分派方式。

- invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找 

  出适合的方法进行调用。 

- invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和 

  父类方法。 

- invokestatic指令：用于调用类静态方法（static方法）。

### 6.4.10 同步指令

编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须有其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。

---

## 第7章 虚拟机类加载机制 

## 7.2 类加载时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称 为连接（Linking）。

![](./imgs/22.png)



面试题：关于在什么情况下需要开始类加载过程的第一个阶段“加载”？

- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
  - 使用new关键字实例化对象的时候。 
  - 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
  - 调用一个类型的静态方法的时候
- 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 
- 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 
- 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。 

**“有且只有”这六种方式会触发类加载机制**

什么是被动引用？

```java
public static class SuperClass{
    static {
        System.out.println(" SuperClass init");
    }
    public static int value = 123;
}

public static class SubClass extends SuperClass{
    static {
        System.out.println(" SubClass init");
    }
}

System.out.println(SubClass.value); // 不会初始化SubClass
```

* 通过数组定义来引用类，不会触发此类的初始化 
* 通过子类引用父类的静态字段，不会导致子类初始化
* 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 

## 7.3 类加载的过程 

### 7.3.1 加载

在加载阶段，Java虚拟机需要完成以下三件事情：

- 通过一个类的全限定名来获取定义此类的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

这里只要获取二进制字节流，至于从哪里获取并没有明确规定，可以从内存、网络、磁盘等方式生成。就如上一张分析的class文件格式一样都行：CAFEBABE000000340016...

**\*数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。**但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：

* 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上
* 如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。
* 数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。 



加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。

### 7.3.2 验证

确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

1.文件格式验证

第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点： 

- 是否以魔数0xCAFEBABE开头。 

- 主、次版本号是否在当前Java虚拟机接受范围之内。 

- 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 

- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 

- CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 

- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。

2.元数据验证 

- 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 

- 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 

- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 

3.字节码验证

- 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。 
- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。

4.符号引用验证 

- 符号引用中通过字符串描述的全限定名是否能找到对应的类。 
- 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 
- 符号引用中的类、字段、方法的可访问性private、protected、public、<package>）是否可被当前类访问。 

### 7.3.3 准备

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，这里的内存分配仅包括类变量，而不包括实例变量。

```java
public static int value = 123; // 准备阶段这个值还是0；value=123会到类的初始化阶段才会执行。
public static final int value = 123; // 因为有final这里会直接就是123
```

char 的零值：'\u0000'

### 7.3.4 解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程

解析阶段中所说的“直接引用”与“符号引用”又有什么关联呢？ 

- 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范》的Class文件格式中。 
- 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

1.类或接口的解析

2.字段解析

3.方法解析 

4.接口方法解析 

### 7.3.5 初始化

初始化阶段就是执行类构造器`<clinit>()`方法的过程。

- `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。

- <clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的 

  赋值操作，那么编译器可以不为这个类生成<clinit>()方法。 

- Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步

## 7.4 类加载器

比较两个类是否相等？

只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

### 7.4.2 双亲委派模型 

**双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

3个系统类加载器：

* 启动类加载器（Bootstrap Class Loader）：前面已经介绍过，这个类加载器负责加载存放在 <JAVA_HOME>\lib目录，
* 扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。
* 应用程序类加载器（Application Class Loader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库。

-----



## 第8章 虚拟机字节码执行引擎

## 8.1 概述

> 执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。 

## 8.2 运行时栈帧结构 

![](./imgs/23.png)

### 8.2.1 局部变量表 

局部变量表（Local Variables Table）是一组变量值的存储空间，**用于存放方法参数和方法内部定义的局部变量**。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。 

局部变量表的容量以变量槽（Variable Slot）为最小单位，每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储。

```java
public static void main(String[] args)() { 
    { 
        byte[] placeholder = new byte[64 * 1024 * 1024];  // 如果这个变量不用这个括号包裹起来，变量槽就不会被复用， 包裹起来后变量a再分配时会使用placeholder的变量槽，原64M内存就可以被回收
    }
    int a = 0; 
    System.gc();
}
```

### 8.2.2 操作数栈 

### 8.2.3 动态连接

每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。通过第6章的讲解，我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

以上是官方解释：

个人对这话理解是：一个方法里面的局部变量比如a，b，c以及方法名add等都是存在常量池的，一部分在类加载的时候做了转化把符号引用转化为直接引用，还有一部分是在运行期将符号引用转化为直接引用，这部分就属于动态链接。

再说说个人对直接引用与符号引用的区别：

```java
public int add() {
    int a = 2;
    int b = 3;
    int c = add(a, b);
    return c;
}

public int add(int e, int f) {
    e *= 2;
    f *= 2;
    return e + f;
}

下面是部分字节码：
Constant pool:
   #1 = Methodref          #4.#23         // java/lang/Object."<init>":()V
   #2 = Methodref          #3.#24         // com/havefun/javaapitest/TestInstruct.add:(II)I
   #3 = Class              #25            // com/havefun/javaapitest/TestInstruct
   #4 = Class              #26            // java/lang/Object
   #5 = Utf8               <init>
   ......
   #18 = Utf8               (II)I
7: invokevirtual #2                  // Method add:(II)I
descriptor: (II)I

```

直接引用：在类加载过程中直接把常量池里的字符拿过来用，比如`descriptor: (II)I`的`(II)I`就是直接引用

符号引用：运行时还需要去常量池找一下这个符号对应的常量字符，比如`invokevirtual #2`这个#2 对应的就是常量池的2的方法+方法签名，这个#2符号引用

## 8.3 方法调用

### 8.3.1 解析

> 所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析（Resolution）

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”（Non-Virtual Method），与之相反，其他方法就被称为“虚方法”（Virtual Method）。 

**动态链接方法解析步骤**

1）找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。 

2）如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。 

3）否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。

4）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

单分派与多分派

择目标方法的依据有两点：一是静态类型是什么，二是方法参数是什么。

![](./imgs/24.png)

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。

### 8.4.3 java.lang.invoke包

```java
public static class MethodHandleTest {
    static class ClassA{
        public void println(String s) {
            System.out.println(s);
        }
    }

    public static void main(String[] args) throws Throwable {
        Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA();
        // 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。
        getPrintlnMH(obj).invokeExact("icyfenix");
    }

    public static MethodHandle getPrintlnMH(Object receiver) throws NoSuchMethodException, IllegalAccessException {
        // MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和 具体参数（methodType()第二个及以后的参数）。
        MethodType mt = MethodType.methodType(void.class, String.class);
        // lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法 名称、方法类型，并且符合调用权限的方法句柄。
        // 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接 收者，
        // 也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo() 方法来完成这件事情。
        return lookup().findVirtual(receiver.getClass(), "println", mt).bindTo(receiver);
    }
}
```

上面这段代码演示了动态绑定，正常来说在编译期就能确定println是哪个类，这种方式把绑定延迟到了运行期。

### 8.4.4 invokedynamic指令

## 8.5 基于栈的字节码解释执行引擎 

### 8.5.1 解释执行 

![](./imgs/25.png)

### 8.5.2 基于栈的指令集与基于寄存器的指令集 

对 1 + 1 这个操作，基于栈和基于寄存器指令集对比：

基于栈的指令集——这种指令通常是不带参数的

```java
iconst_1	// 将两个常量1压入栈
iconst_1	// 将两个常量1压入栈
iadd		// iadd指令把栈顶的两个值出栈、相加，然后把结果 放回栈顶
istore_0	// 把栈顶的值放到局部变量表的第0个变量槽中。
```

基于寄存器指令

```c
mov eax, 1	// mov指令把EAX寄存器的值设为1
add eax, 1	// 后add指令再把这个值加1,结果就保存在EAX寄存器里面
```

基于栈指令集的优点：

* 基于栈的指令集主要优点是可移植，因为寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。
* 代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）
* 编译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈上操作）

缺点：

- 理论上执行速度相对来说会稍慢一些（解释执行的情况），如果运行JIT即时编译输出物理机上的汇编指令流，就与虚拟机采用那种指令集没有关系。
- 指令数量会变多，出栈入栈都需产生额外的指令，基于栈的也会更频繁访问内存，更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是优化措施而不是解决本质问题的方法。

### 8.5.3 基于栈的解释器执行过程 

以下面的代码做分析：

```java
public int calc() {
    int a = 100;
    int b = 200;
    int c = 300;
    return (a + b) * c;
}

// 字节码如下：
public int calc(); 
	Code:Stack=2, Locals=4, Args_size=1 
        0: bipush 100 // bipush 将单字节的整形推入操作数栈顶 栈顶 100
        2: istore_1 	// 将栈顶的100存入局部变量表1   
        3: sipush 200 // 将200推入操作数栈
        6: istore_2 	// 将200存入局部变量表2
        7: sipush 300  // 将300推入操作数栈
        10: istore_3	 // 将300存入局部变量表3
        11: iload_1  // 将局部变量表1的数据压入栈顶  操作数栈：100
        12: iload_2 // 将局部变量表1的数据压入栈顶 操作数栈：100 200
        13: iadd 	// 将操作数栈的两个数相加 操作数栈：300
        14: iload_3 // 将局部变量表3的数压入操作数栈 操作数栈：300 300
        15: imul 	// 操作数相乘 300 *300
        16: ireturn  // 返回操作数栈顶的90000
}
```

![](./imgs/26.png)

---

## 第10章 前端编译与优化

```java
Integer a = 1;
Integer b = 2;
Integer c = 3;
Integer d = 3;
Integer e = 321;
Integer f = 321;
Long g = 3L;
System.out.println(c == d); // true
System.out.println(e == f); // false
System.out.println(c == (a + b)); // true
System.out.println(c.equals(a + b));    // false
System.out.println(g == (a + b));   // true
System.out.println(g.equals(a + b)); // false
```

“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们equals()方法不处理数据转型的关系。

----

## 第12章 Java内存模型与线程 

